# Enterprise Web Architecture

## INTRO

이 기술이 편한가 다른 사람도 편하게 생각하는가? 거기서 yes라면 선택될 가능성이 높은 기술인 것.

IT 분야에서는 끊임없이 공부하는 것이 중요.

공부한 것이 6개월 뒤에는 구닥다리가 되는 경우가 많음. 허무함. 정보의 홍수 IT의 홍수 때문.

잘못 선택했다는 자괴감과 실패감이 자꾸 들어서 이 분야가 힘들게 느껴지는 것.

수동적으로 행동하는 사람은 그런 느낌이 적을 수 있음. 하지만, 도전을 많이하면 많이할 수록 실패감이 커짐.

교육시장에서는 가장 핫한 것을 원하기 때문에 그것을 강의로 만들기 위해서는 하나를 가르쳐주기 위해 관련된 10개를 알고 있어야함.

하나를 알기 위해서는 5개를 알고있어야함. 전달하기 위해서는 주변 10개를 알고 있어야함.

웹 디자인 강의를 들어야되는데 웹마스터 강의를 듣게됨. 아무리 배워도 포토샵을 안 함  끈기있게 1달이나 들음. 1달 들었으니 끝까지 들음. 그게 바로 JAVA였음. 놀라운 만남.

열심히 다른 사람과 서로 가르쳐주고 배우는 과정을 본 강사님이 자격증(20만원짜리) 따보라고 함.

그래서 친구따라 강남간다고 친구가 딴다고해서 같이 가서 봤는데 붙음.(SCJP)

따고나니까 강사님이 강사해보는 것 어떻냐고함. 전달력이 있다는 것을 종합해서 보신 듯...

강사 하니까 한주 봉급이 한달 월급.. 그래서 더 열심히 공부해서 전향

좋은 개발 회사에도 들어감. 5년동안 4시간이상 안자면서... 1년동안 1일 8시간 투자하면 전문가가 됨. 그건 참 멋진 일임. 취미여도 전문가가 될 수 있음.

어찌어찌하다가 SUN에 입사. 낙하산이라는 얘기도 들음. 근데 친해지면서 하나님의 은혜로 인정받으심.

SUN 강사들이 원서로 강의하는데 끄적거린게 없을정도로 전부 머리 안에 들어가 있음.

수준에 못미치면 3개월간 다시 공부시키는 스타일로 훈련받은 사람들.

거기 선생님이 들어갔을 때 SUN 선생님들이 그렇게 훌륭한 사람들인데 라꾸라꾸 가져와서 잠도 안자면서 공부함.

천재들을 따라잡으려면 엄청난 노력을 해야됨.

그리고 26살 새내기 강사가 들어옴. 낙하산 아니야? 생각했는데 솔라리스 강사님인데 솔라리스 설치만 130번 설치해봄. 당시 OS 설치에 1시간씩이나 걸렸는데...

지겨웠을텐데 했다는 것이 대단. 그만해도 될텐데 하는 생각이 들었을텐데 끝까지 한게 대단.

## Web Architecture

세로로 구획을 나누는 것을 Tier라고 함.

Client Side와 Server Side를 나눔.

Client Side는 Web browser 이용자들. 근데 기종이 서로 다르고 웹 브라우저 종류도 다 다름.

최근에는 모바일을 통해서도 웹브라우저를 사용.

http 프로토콜로 인캐스트를 하면 그걸 받을 수 있는 서버가 필요.

서버 도식



Any Web Server(Apache, nginx, IIS, NS, ...)[표준 http 프로토콜을 이해하는 프로그램]

웹서버는 하드웨어 부분에 메모리 하드디스크(이 안에 파일시스템이 있음)

웹서버마다 기준 디텍토리가 다른데 그 기준 디텍토리 밑에다가 html이라는 파일 또는 CSS라는 파일 또는 js라는 파일을 넣었음.

초창기에는 웹브라우저가 요청하면 text를 응답해주는 구조였음

```html
<html>
<body>

<h1>hello</h1>

</body>
</html>
```

tag의 그룹 클래스라고 부르는 그것을 통해서 같은 그룹들을 어떻게 보여지게 할 것인지를 기준을 정하는 문법이다. 화려한 형태의 브라우징을 가능하게 함. 하지만 이런 수준의 html으로는 로그인이나 기타 기능을 제공할 수 없었음. 사용자를 인식 식별 처리 하는 CGI 프로그램이 필요해졌음.

다양한 언어들로 만드는 것을 시도해보았는데 됬던 것을 CGI는 request가 process단위로 돌아간다는 문제와 platform dependency 문제가 있었음.

Request가 오면 처리할 메모리는 중간에 그림.

은수라는 Request가 오면 그 해당 메모리 구역이 생기는데 이것을 Process라고함.

길동이 똑같이 웹브라우저로 Request를 했다면, OS에서는 길동이를 위한  Process를 다시 하나 띄움.

지현,도현 등등 있다고 치면

이런 Process들은 서로 자원을 공유하지 않음.(엄밀한 의미에서 자원은 Process업무를 의미함. 교류가 안되는 메모리 구역을 갖습니다.)

Request 건수마다 Process를 부여하는 것은 메모리도 하드웨어 리소스도 부족하게 만드는 자원의 낭비가 발생하게 만듬. 그래서 이것을 Thread 기반으로 옮기자는 제의가 나옴.

Thread란 하나의 Process안에서 동작하는 Sub Process.

옛날형 CGI가 아닌 Thread 기반 CGI인 NSAPI와 ISAPI 등등을 통해서 명령이 내려오면 은수의 Process가 아니라 Web Application Process가 하나 뜸.

여기서 윈도우 탐색기라는 프로그램을 꺼내서 이것을 실행했다고 쳐보자.  그러면 메모리 영역에서 윈도우 탐색기를 구동하기 위한 프로세스를 띄우고 하드웨어까지 전달이 됨.

cmd라는 프로그램 띄워도 마찬가지. 여러개 띄우면 그만큼의 Process가 계속 띄워져 있어야함.

하드웨어 자원은 한정되어있는데 나눠서 사용해야되서 일일히 띄우는게 아니라 Web Application 위에서 Server가 돌아가도록 만들어야함.

Thread를 그림을 그리면 Application Process 안에 은수를 위한 Sub Process가 따로 뜨는 것임 . 길동이 Process가 필요하면 길동이 Thread가 뜸.  Application process 안에 참조해야할 것이나 Code가 있으면 Sub Process들이 이것들을 같이 사용함.

메모리 상에 올라와있는 정보, 이 정보를 올리기 위해서 수행해야할 Code를 공유하는 것을 Thread라고 한다.

개발자 입장에서는 Thread기반 Process가 기존 방식보다 훨씬 가벼워서 더 많은 Process를 감당할 수 있게 되었다.

문제는 한 1000명쯤 들어오면 Thread도 뻗어버린다. 그러면 이런 Server를 하나 더 만들자는 아이디어가 나옴.  그 서버를 추가하면 load balancing을 통해 너는 여기서 처리하고 너는 저기서 처리하고 맞춰줘야한다. 분산해줘야한다.

그런 형태가 되도록 구성하려면 현재 말하고 있는 이 상태와 똑같은 상태가 가장 좋지만 그렇게 잘 안되니까 하나를 더 만든다.

새로 만들어진 것은 건물도 다르고 운영도 다르다(하드,O/S 둘다 다름)

그래서 Application도 달라진다.

문제는 NSAPI와 ISAPI로 짠 것을 그대로 넣을 수가 없어서 개발자들이 힘들어하는데 vendor들이 이를 무시함. 이것을 Platform 종속성이라고 함. 요즘도 이런 Platform 종속성은 아직 남아있음. (ex: Orcale, Microsoft)

이것을 해결하기 위해 착한 기업이었던 SUN... 망해버림 ㅠ 개발자들 진작 좀 써주지.

IBM에서 만든 eclipse라는 툴은 일식이라는 뜻. Sun을 가리겠다는 의미에서 나온 것.

SUN에서는 lab beans 만들었는데 좋은 툴이지만 전파가 안됨.(익숙한 툴을 바꾸기가 힘듬.)

여기서 Sun이 Servelet을 만들어서 Thread문제와 Platform문제를 해결.

Any O/S(멀티 캠퍼스에서 501호에는 A반을 구동하세요 느낌)

Any H/W(하드웨어는 멀티캠퍼스의 건물과 같은 느낌)

가로로 구획을 나누는 것을 layer 또는 stack이라고 함.

Servelet으로 그림을 그렸을 때  오각형으로 자주 그림.

UML 이라는 그림 표현 방식이 있음. 여기서 Component Diagram이 있는데 Component를 마치 레고 조각처럼 플러그로 표현함.(끼워서 쓸수 있게)

Component끼리 서로 끼워져서 붙어있음(블록들처럼)

하나의 Component는 여러개의 Class와 Code들을 포함할 수 있음.

하나의 Component와 고객 가입로그인 삭제 탈퇴 등등 있다면 이것을 고객 Component라고 부르고

상품에 관해서는 상품 Component, 구매에 관해서는 구매 Component가 됨. 이것들이 모여서 쇼핑몰이 됨.

코드들의 집합을 Servelet으로 짜고 싶다면?

이 Component를 5각형으로 그리면됨. 아 그러면 이게 Servelet 코드구나 할 수 있어야함.

Component이긴 하지만 Code가 가장 작은 형태로 얘기해보려고함.

Servelet에 최소의 코드를 가지고 만들 때 로그인 기능을 구현한다고 해보자.

회원에게 ID와 PW를 요청한다고 해보자.

http 프로토콜을 이용해서 해당하는 페이지의 첫 페이지를 달라고 요청함. www.jes.com/

이렇게 뒤에 아무것도 안나왔을 때는 서버가 자동으로 index.html을 찾아서 보여줌.

ID field에 data를 넣고 PW field에 data를 넣은다음에 버튼을 딱 누르면 URL에 주소가 바뀌면 안좋은 사이트 안바뀌면 좋은 사이트.

http://www.jes.com/login?id=a&pw=b

html에서 css js아닌 것은 못알아들어서 404 에러를 띄움.

찾을 수 있게 해주기 위해서는 CGI와 연동을 해줘야함. 하지만, 직접적으로 연동이 안됨.

그래서 JAVA SE를 깔아야함.

여기에는 JDK라고 하는 도구와 JRE라는 도구라는 JVM라는 도구가 있음.

JRE는 실행 환경. 이 실행환경에서 제공하는 라이브러리가 있음.(rt.jar 런타임 때 제공되는 라이브러리)

이 라이브러리 안에서는 support를 제공안해줌.

Java EE의 라이브러리에서 support를 제공해줌(ee.jar)

여기있는 코드로 servelet을 작성하면 compile까지는 되는데 실행이 안됨. 속이 텅 비어있어서.

interface로 되어있어도 코드 작성은 됨. 하지만, 실행이 안됨.

그래서 실행을 하려면 안에 코드를 채워놓은 구현체가 필요한데, 이 구현체들을 Implemantaion이라고 함. 이것을 Web container라고 함(Tomcat, Resin,JRun)

본인이 못 알아듣는 URL에 대해서는 에러를 내지 않고 넘기기로 하고 SE와 EE가 연동되어있음.

SE에서 이해 못하면 Web container로 넘겨줌. 여기에 설정 파일(EE의 설정파일)에 설정된대로 넘겨줌.

servelet에서는 java코드니까 java를 실행시켜줄 스택이 필요함. enterprise edition은 반드시 standard edition stack이 필요함.

여기서 Eclipse와 같은 개발 툴이 있다면 이것도 Java EE위에 하나의 Stack이 되는 것임.

Eclipse는 메모장과 같은 역할.

Mainservelet.java로 코딩하는 역할.

이것을 컴파일하고나면 mainservelet.class라는 텍스트가 아닌 인간이 알아볼 수 없는 형태의 파일이 생김.

저 class는 JRE가 알아듣는 영역.

machine이 알아들을 수 있는 것은 전기가 들어온 것 안 들어온 것 딱 이 수준. (1과 0)

하드웨어마다 0과 1의 체계가 다름. (같은 명령도 1100 1111이런 식으로 다름)

그런 machine 명령어를 내려주는 OS와 긴밀한 관계를 맺고 있어야하는데  이 하드웨어의 종류와 Application 종류에 따라서 호환이 안되는 Platform종속성 문제가 발생.

servelet으로 알고 작성한 이것은 모든 OS와 모든 Hardware가 알아들을 수 있는 형태로 작성되는 것이 아님. 그래서 JRE라는 해석기가 필요함.

JRE가 해석해주는 언어가 class임. 이 class는 machine 코드는 아님. byte code임.(jre가 알아듣는 언어)

.java는 machine code가 아니라 사람이 알아듣는 언어. 자연어.

JRE를 class loader라고 함.(class를 읽어오는 애 byte code를 읽어오는 애)

servelet을 읽어오라는 명령이 들어오면 class loader에서 class 파일을 읽음. 이것과 같이 맞물려 가는 것이 bytecode verifier. (바이트코드 검수자)

class 파일은 최상단에 0xCAFEBABE라고 적혀있음.(도장임. 정당하게 JAVA로 컴파일 했다는 증거. 매직 코드라고 부름.)

java는 네트워크 기반 언어임. 혹시나 해커가 침입해서 똑같은 이름의 악성코드를 심어놨을 가능성이 있기 때문에 증거가 필요.

mainservelet.java를 확장자만 바꿔서 class로 바꿨을 때 검증할 수 있는 도구가 바로 bytecode verifier이다.

정당하게 JAVA로 코딩된 코드만 읽어줌.

JAVA는 문법이 까탈스러움. 그렇게 코딩해도 끝까지 검수함.

stack overflow나 underflow가 일어나지는 않았는지 timecast는 맞는지 확인함.

그래서 JAVA는 느림. 근데 이것이 Enterprise의 수요를 충족.

multi user를 수용하는 system은 다 enterprise system이라고 함.

검수를 다 하고난 뒤 마지막 engine이 돌아감.

얘는 괜찮은 것 같으니까 머신코드로 바꿔 하는 이 친구가 machine code generator.

어떤 OS를 쓰는지 어떤 Hardware를 쓰는지 알아내서 그것을 적절한 machine code로 바꿔서 JVM(핵심 machine, core machine)에 넘겨준다. 

JVM은 01010111010로 된 코드를 받아들이는 것.(load 한다고 함.)

# Load 이후 과정

## heap 영역

### Instance(객체)

1. Young Generation

   1.eden

   2.survive

   -survive 1

   -survive 2

2. Old Generation

### method area(구조)

1. 일반 구조 영역
2. static member들이 올라가는 영역
3. final member들이 올라가는 영역
4. String leral pool 영역

## 기타 영역

1. stack (local data가 올라가는 영역)
2. pc-resistor 영역
3. non-heap 영역

 





여기부터는 멘붕할 수 있음 어려워서.

load 이후의 과정.

(main)이라고 하는 method를 제외한 static member 초기화 작업을 함.

이것을 초기화 하면 code중에서 static이라는 keyword가 있는 것을 java에 올린다는 얘기.

(뭔가를 메모리에 올린다.)

여기서 메모리 구역으로 넘어간다.(원래 하드웨어에 있는 것.)

java application 이 구동될 때는 건물에 메모리를 이만큼 할당해주세요. 요청함 근데 할당받을 때마다 사이즈가 달라서 사이즈가 딱 얼마다 얘기하는 것은 무의미함.

java application을 구동할 때 고정해서 딱 이정도는 해주세요 할 수 있음(ex:256mb, 1gb로 해주세요)

java application구동할 때 설정할 수 있음.

이렇게 잡히는 메모리를 어떻게 나눠서 설정할 수 있는가?

메모리 구역을 heap 영역과 기타 영역으로 나눔

heap영역은 다시 반으로 나뉨.

한쪽은 instance영역(객체가 올라가는 영역)

다른 한쪽은 method area(구조가 올라가는 영역)

instance영역은 다시 반으로 나뉨

한쪽은 young generation(젊은 세대, 객체중에서 젊은 객체가 올라감)

한쪽은 old generation(늙은 세대, 객체중에서 늙은 객체가 올라감)

young generation 공간은 다시 반으로 나뉨.

eden(신생아 영역, 가장 젊은 객체)

survive영역이 2개로 나뉨

survive1과 survive2로 나뉨.

method area도 다시 둘로 나뉘어서

일반구조가 올라가는 영역이 있고

static member들이 올라가는 영역들이 있고

final member들이 올라가는 영역이 있음.

final member들 안에는 string literal pool(문자열 들이 올라가는 구역)이라는 구역이 있는데

문자열들 올라가는 구역임

기타영역은 3가지로 나뉘어짐.

1.stack 구역

문자는 똑같지만 똑같은 의미는 아님. architecture적으로 stack(=layer)이라고 하는 것과 다름. stack은 마치 연탄처럼 그렇게 쌓임. 맨 밑장 윗장 윗장 이런 식으로.위로쌓기. 꺼낼 때는 맨 위에 있는 것부터 꺼냄.

어떤 데이터를 순서대로 쌓았다가 맨 위에 있는 것부터 빠져나오는 영역.

누가 stack이라 불렀는데 이견없이 stack됨.

이 구역은 데이터를 연탄처럼 쌓는 구역이다. java에서는 local 데이터를 쌓는 구역.

2. PC resistor 구역

heap이나 stack에서는 저장을 해놓고 다 사용해야 없어지는 어느정도 수명이 긴 저장소라면 resistor는 아주 스팟성이어서 연산할 때 잠깐 저장했다가 바로 없어지는 휘발성이 강한 영역이다.

자바는 thread기반으로 돌아간다. 여러 Thread들이 CPU가 하나밖에 없으므로 CPU에 올라가있는 녀석만 동작가능함. CPU가 하나밖에 없는데 처리해야할 Thread가 많다면 기다려야함. CPU가 의자. 앉는 사람만 선생님한테 질문할 수 있다면 질문자들이 Thread. 다들 의자에 앉을 수 없으므로 나머지는 wating 영역으로 가야됨. 이것을 관할하는 것이 OS임.

OS에서는 공평하게 Thread에 시간을 할당함.(처리할 시간이 부족하더라도)

선생님, 말하고 까먹지 않도록 각 Thread들이 내가 어디까지 얘기했었는지 기억하도록해주는 장소가 PC Resistor이다.

3. non-heap영역

각 vendor 마다, JVM vendor를 말하는 것. 다르게 사용하는데 JVM에서 사용하는 code cash 영역을 사용함. 완전 전문가 영역이라 잘 드러나지 않아서 인터넷으로 찾아봐도 별 내용이 안나오고 사람들이 잘 나오지 않음.

많은 JVM vendor들이 있음. 근데 우리 스펙에만 따르면 허용해줌. JVM이 표준 규격에 맞게 입맛에 맞게 운영하고 있음. 근데 Microsoft가 Sun JVM을 쓰면서 Microsoft JVM이라고 자기들이 맘대로 씀.

소송 걸었는데 Microsoft가 8년을 질질 끌음.

SUN이 이기긴 했는데 너무 시간 오래걸려서 너덜거림.

mainservelet의 data와 method는 static영역으로 올라감.



load이후 초기화이후 상속관계 파악으로 넘어감.

상위 종속관계가 있는지 파악. 없으면 찾으러 돌아다님, 내 작업공간만 다니는 것이 아니라 ee.jar와 rt.jar를 다 뒤져봄. ee.jar는 비어있는게 확실함으로 구현체나 rt.jar쪽에서 찾아서 class loader를 찾아서 옴. 상위 관계를 발견하면 class loader로 넘겨서 하드웨어로 보내고 또 static에 들어가는 data와 method발견하면 다시 반복.

이 일련의 과정을 dynamic load라고 함.

미리 다 읽어놓고 찾는 것과 필요할 때마다 연관관계가 있는 대상을 찾는 것 둘중에 전자가 무조건 빠름. 후자의 특성은 느림.

java는 전자처럼 안하고 후자처럼 함.

그렇게 하는 이유는 network언어이기 때문이다.

framework를 쓰면 과중하게 연관되어있는 애들이 많아짐.

그런 애들을 하나하나 다 찾아다니고 머신코드 읽고 검수하려면 메모리 올라가기도 전인데 너무 과정이 많음. 그래서 느릴 수 밖에 없음.



JAVA 전문가라면 heap영역과 stack영역을 정말 잘 알고 있어야함.

끝이 object인 class에서는 상속관계가 없으므로 root로 내려감.



상속관계가 없는게 확인 되면 객체 생성됨. new라는 keyword를 할당하는데 이건 eden 영역으로 보내라는 얘기. 객체가 생성될 때는 data와 method가 올라감. 예를 들어 member라고 하는 객체를 만든다고 하면 member의 data중의 이름이라는 data가 있다고 하자. 전은수. member 데이터가 하나 더 만들어져야한다. 전도현. 이것들은 각각 따로 만들어져야한다.

제임스 고슬링이 추구한 것은 사람이 생각하는 것을 컴퓨터가 대신 해줄 수 있는 것을 지향함. 다른 정보의 집합이 다른 메모리 구역을 가지도록해서 존재감을 갖도록 함.

똑같은 사람이라고 불리는 객체인데도 각각 이름이 다르듯이 위에서 말한 것처럼 구분함.

method는? 모든 사람들은 다 밥을 먹고, 걸어다니고 말을한다. (기능) 그것도 memory에 올라가야함. 각각 method도 따로따로 가지고 있어야하는게 맞음. 하지만, 이 method는 data하고는 다름. 읽고 수행해야하는 code에 가까움. data는 정보임. 값을 갖는 정보. method는 읽고 앞으로 수행해야돼 하는 코드임. member라는 class를 통해서 member 객체가 3개 만들어졌다면 compile을 1번했으니까 method에대한 0과 1코드도 전부 동일할것(3번에 대해서). 그래서 3번 똑같은 행위를 반복하는 것은 메모리 낭비하는 것이므로 언제 이것이 달라질지 보니 소스코드가 바뀔 때 뿐임.

그래서 method는 여러 장소에 올리는 것이 아니라 일반구조영역 member의 method를 를 다 올리고 young generation의 eden영역에 연결될 수 있도록 설계를 해두었음.

메모리의 한계가 없는 영역에 살고 있다면 이렇게 까지 할 필요가 없고 객체들이 따로따로 method들을 가질 수 있는 세상이 될 것.

이 객체들이 만들어질 때는 객체들의 위치라는게 정해짐. 그래서 memory에 주소가 할당됨. 각각 100번지 200번지 300번지라고 하자. 코드에서 전은수를 찾아서 예쁜 전은수로 바꾼다고 해보자.  주소는 우리가 못 알아듣는 숫자로 되어있기 때문에, 기타영역 stack 영역의 local영역에서 1번은 100번지를 가리킬께요. 이런 명령에 대한 문법적 정의가 필요하다.(문법적 지식이 필요)

이러다가 한 멤버가 더 만들어져야하는 상황이 생긴다면?

C를 공부할 때 메모리가 부족하기 전에 지우고 memory에 올라갈 수 있도록 해줘야함.

그렇게 안하면 out of memory 가 되버림. 근데 이런 것을 커버할 수 있는 개발자들이 적음. 그래서 고슬링이 memory 청소코드를 미리 만들어둠. 그래서 한 프로세스의 하나의 메모리를 할당받아서, instace영역에 눈에 불을 켜고 찾고있는 청소코드가 쓰레기가 아닌 객체들을 survive영역으로 옮겨놓고 나머지를 전부 지워버림.

보통 방에서는 쓰레기가 아닌것을 치우는 것보다 쓰레기를 줍는게 더 빠름.

하지만 쓰레기가 너무 많으면 그냥 밀어버리는게 빠름.

프로그래밍할 때 한번 garbage collection이 들어올 때 쓰레기가 많이 들어오게 짜야한다는 얘기.

이 얘기를 JAVA개발 7~8년 한 사람한테 얘기해도 처음듣는 얘기라고 함.

JAVA는 객체지향. 객체를 많이 만들어내는 것을 선호함.

북치고 오면 북이 return되는 시점에 사용한 객체는 garbage가 되어야함.

장구치고 오면 장구 return 시점에 사용한 객체는 garbage가 되어야함.

북치라고 해놓고 return이 안되니 garbage가 아니게 됨.

근데 다 garbage가 아니게 되면 메모리가 부족해짐.

이렇게 되면 survive영역으로 옮겨야할게 많아져서 문제가 생김.

garbage collection에서 survive1으로 가는 것은 5~10%미만이 되어야한다라고 함.

infant motality (영유아 사망)이 필요함. 한번 쓰고 다 버려지는 것. 이게 JAVA의 객체 지향임.

필요한 애들 모두 올려놓고 사용하는 것은 옛날 스타일 기법. 이 습관대로 짜면 객체들이 하나도 안 죽고 다 살아있어서 메모리 효율성이 떨어짐.

stack 영역은 method 호출 영역. 

a호출 b호출 c호출 하면 c끝 b끝 a끝 이 순서.

끝나서 리턴 들어오면 stack 영역이 다 사라짐. 옮길 애들이 없어지면 garbage collector들이 다 지워버림. 이렇게 JAVA 코드를 짜야함.

만약 다 살아있으면 survive 영역으로 들어감. 이게 객체 나이 1살.

그다음 살아있는 애들을 survive2로 이동시키고 survive1에서 살아있는 애들을 survive2로 이동하고 eden과 survive1을 청소. 그다음은 survive2에서 살아있는 애들을 survive1으로 옮기고 eden과 survive2를 청소. 반복.

오래 살아있으면 oldgeneration으로 이동함. 이건 한번에 지우는게 아니라 죽었는지 살아있는지 하나씩 다 물어봄. 경로우대. 여기서 완전히 삭제나기전 마지막 유언을 들어줌 이걸 final rise method라고함. 이걸 그냥 구현하면 엄청 느려짐. 그러면 삭제 후 구멍이 뻥뻥 뚫린 상태에서 구동될수 없어서 이 메모리들을 한군데 밀어서 정리를 하고나서야 가동할 수 있다.

너무 느려서 stoptheworld라는 별명도 붙어있음. 메모리 할당과 해제로 이걸 해결할 수 있는게 아니라 코드 어떻게 짤지 디자인할 때 결정됨.

garbage collector는 method영역은 쳐다보지도 않음. method영역은 perm gen(permanent generation)이라고 부름. 영원한 세대. 여기 올라간 것들은 프로그램이 종료할 때까지 안 사라짐.

new member servelet이 있다고 해보자. 여러가지 이름이 붙은 객체가 생성되게 했다고 해보자. 1000명이 동시에 회원가입을 했음. 1000개의 멤버 객체가 생성. db까지 저장되야 회원가입이 완료되는데 eden 영역이 부족 그러면 survive1,2로 가는데 그것도 부족하면 다 old generation으로 감.

이제 멤버들이 db로 저장되고 난 뒤에는 필요 없어진 것들을 지워야 하는데 메모리가 모자라야만, garbage collector가 삭제함. 그래서 삭제 안되고 남아있음.

이제 1000명이 로그인한다.

개발자가 로그인할 때 new connection이라는 코드를 짰다고 해보자

1000개의 커넥션이 생김.

old generation을 이제서야 지움. 엄청 느리게.

근데 사용자들은 로그인 안되니까 엔터 한번 더 누름

그러면 또 request. 그러면 더 느려짐.

또 enter누르면 또 request 더 느려짐.

점점 더 나빠지는 상황이 연출됨.

사실 튜닝이 아니라 처음부터 이런 문제가 안 생기도록 코딩했었어야함.

운영자들은 이런 상황을 모르니까(운영시점에 생기는 문제) 그냥 칼같이 서버 증설해버림. 증설한다고 해결되는게 아니라 증설하고나면 클러스터링 문제 관리 인건비 문제, 서버 성능의 20~30%만 사용되고 70~80%는 노는 기타 문제 상황이 발생함.

그래서 클라우드 시스템에 대한 요구사항이 생김. 운영자들은 그냥 잘만 구조화하면 10대를 2~3대로 하고 비용이 안 발생하게 할 수 있는 건데 그냥 클라우드 써버림.

신기술=善은 아님. 보안전문가는 정말 잘 알고 있고 경각심을 가져야함.

member들의 객체 정보가 각각 들어오고 code를 공유해서 일반 구조 method를 공유하는 것이 thread 기반 처리 방식이다.

다른 CGI도 thread 기반으로 만들었을 때 똑같을까? 아니다. platform dependancy문제가 있어서 다른 CGI가 적용하려면 다 뜯어고쳐야되서 문제가 생긴다.

byte code를 만드는 것 까지가 개발. 이 개발된 것을 읽어와서 classloader로 가서 과정을 거쳐서 실행이 되는 것.

JAVA는 JRE가 안깔려있으면 못돌아감.

Sun에 가서 자기 OS용 JRE를 다운로드하면 설치해서 사용가능하다.

servelet을 플랫폼에 맞춰서 새로 만들지 않아도 되어서 이점인 것이다.

```java
class Hello{
    public static void main(String [ ]a){
        System.out.println("Hello");
    }
}
```

이것을 바이트코드로 짜서 작성할때는 3배의 코드. 머신 코드로 짜서 작성할 때는 15배 길이의 코드가 필요.

JAVA만 이런건 아님.

윈도우 운영체제에서 cmd prompt를 켰다고 해보자.(메모리가 할당된 것.) dir을 치면. 이게 자연어인것. cmd를 돌려주는 엔진이 dir를 알아들을 수 있는 0과 1로 바꿔서 전달을 해준다. 그러면 현재 위치에 있는 하드 디스크의 내용을 화면에 리스팅해라 라는 명령이 오고, 메모리에 그 결과들이 다 올라감. 그리고 그 결과가 출력됨.

리눅스 우분투 운영체제에서 terminal을 열고, ls를 치면 해석해서 결과를 보여주는 도구가 shell임. 그래서 이 명령어들을 shell 명령어라고 함.

이 명령어들을 하드웨어에 최적화된 0과 1로만 만들어줌. 이 쉘 프로그램을 가지고 윈도우즈 위에서 실행시키면 못 알아들음. 해석할 수 없는 능력이 없기 때문.

프로세스와 프로그램의 차이에 대해 얼핏 이해가 되었다면.

엔터프라이즈 환경에서는 JAVA가 최강이어서 구축을 했다면, JAVA는 점점 개발 편의성을 추구한다는 것도 이해해야한다.

여기서 그래서 framework가 들어간다. framework는 new하는 코드들을 대신 해주는 것. 요즘 아이디어들은 xml을 사용하는 아이디어가 많음.

```xml
<bean class=Member></bean>
<bean class=connection></bean>
```

이런 xml파일들을 읽고 다시 코드로 만들어주는 것을 parser라고함. 다시 코드로 바뀌면 아까 new member이런 것들과 비슷하게 됨. 읽고 쓰는 것까지 다 코드로 만들어줌. 그래서 5배 코드가 증가. 그래서 그렇게 만든 코드를 bytecode로 만들면 3배 증가 0과1로 만들면 15배증가.

변경되는 순간 전부 string 포맷으로 바뀜. 그러면 string leteral pool의 공간이 부족해짐.

old generation 공간도 없고 string leteral pool 공간도 없으면 out of memory됨.

계속 필요 메모리가 증가하는 것을 memory leak이라고 칭함.

이렇게 out of memory error가 생기면 복구하는데 오래걸림.

개발 편의성을 추구하는데서 오는 잘못된 구조로 인해 메모리 누수가 증가하고 하드웨어 비용만 증가하고 뒷일은 감당이 안되게 됨.

기본에 충실하자 는 개발자가 명심해야하는 것.

개발자보다 더 중요한 것은 architect.

까다로운 관리 감독을 해서 청사진대로 되도록 해야함.

다리가 무너지는 것은 엄청나게 관리감독을 하지만, 소프트웨어는 관리감독을 하지 않는 것이 문제.

경험상 운영자들은 이렇게 생각함. 장애 대응을 하기 위한 여분의 서버를 많이 확보하지만, 준비하기 위해서 기간의 특정성을 찾아서 서버가 죽기전에 정기점검을 빌미로 out of memory 사태가 나기전에 서비스 접근을 막음.

framework의 비효율적인 메모리 활용 방식으로 인해 모든 메모리 영역을 차지하게 됨.

책 읽어주는 서비스가 있다고 치자. 책 찾는데 시간을 줄여줄 필요가 있음. 그러기 위해서는 분류해놓은 책장이 필요. 이 책장 역할을 하는 것이 framework. 근데 framework는 꼭 필요한 것이 아님. 없이 개발할 수도 있음.

명장은 도구 탓을 하지 않는다. 하지만 요즘은 전동드릴 없으면 어떻게 해요?하는 세상에 살고 있음.

System이 기본적으로 허약한 상태에 있다면 DoS공격에 취약하게 됨.

open source framework이라는 엄청난 책장을 들여와서 책을 꼭꼭 채워놓는다는 것.

어떤 기술을 맹신하고 추종하는 것을 지양해야함. 다 선은 아니다.

다들 신봉하는 기술 속에 해커들이 좋아하는 취약점이 생기는 것.

보안 전문가가 해야할 것은 취약점을 없애는 것이 아니라 약점을 없애야 한다.

강동주 대표는 벤처로서 성공을 한 것. 벤처 기반을 물어보기에 최적화 되어있음. 거인의 어깨 위에서 모든 것을 바닥부터 만들지 말고 다양한 오픈소스와 API를 가지고 인사이트를 갖고 개발하세요.라고 말함.

보안전문가입장에서 봤을 때는 상충됨. 거인의 어깨(enterprise)에서 만들기에는 취약한 부분이 상당히 생길 수 있다는 것을 명심.

JAVA의 문법과 가치관이 너무 좋다고 매료된 Netscape회사의 엔지니어가 있었음. 이 사람이 꼭 서버쪽 뿐만 아니라 클라이언트 쪽에서도 패스워드를 안 넣고 로그인 버튼을 누르면 실패해야한다. request가기도 전에 web browser에서 공란을 먼저 체크하는 프로그램을 만들고 싶어함.

cgi는 웹서버 위에서 돌아가는 프로그램이라고 한다면, 이 프로그램은 web browser위에서 돌아가는 프로그램이어야 함.

그래서 브라우저 위에서 돌아가는 것을 java로 짜봐야지 했음. 여러가지 문법이 너무 많아서 모든 것을 가져오지 못하고 필요없는 문법들을 쳐내서 javascript라는 이름을 붙임.

java와 문법은 닮아있지만 느슨함. 느슨함이 도움이 될 때는 대충 짜도 돌아갈 때, 문제가 될 때는 나조차도 어디가 잘못됬는지 알 수 없을 때.

이 개발자가 javascript를 만들면서 문법도 느슨하지만, 실제 실행할 때도 이렇게 컴파일해서 머신코드로 움직이면서 장황하게 움직이는 것을 기대할 수 없었음. 사용자 컴퓨터는 서버와 비교가 안되는 상황이기 때문. 쉽게 동작할 수 있는 방법을 만들어낼 필요가 있었음.

그래서 컴파일하지 않고 읽고 바로 머신코드로 만들어서 실행하는 것을 생각해냄. 이것이 script. 이것을 script형 언어라고 한다. 이것을 interpreting 언어라고 함. 이것을 해주는 엔진을 interpreter라고 함. 이것을 netscape browser안에 내장시켜놓음. 

사용자는 javascript를 짜는 사람이 아님. 서버쪽에서는 html를 개발하는 사람이 web designer. 이 디자이너들이 공간을 빈것을 체크해주는 javascript를 짰음. 브라우저는 html를 서버에서 받아와서 거기에 <script>가 들어간게 있으면 엔진에 돌려서 바로 실행해주는 것.

도착했을때 링크라는게 있는 것을 보고 다시 javascript를 달라고 요청함. 그러면 또 javascript가 보내져오고 브라우저 엔진에 의해서 해석이 이루어짐. 

로그인버튼을 누를 "때" 해석이 되게 하고싶으면 지연시킬 수 있음.

head에 넣으면 지연시킬 때 더 효율적임.

node가 나오기 전에 90년대 중반부터 javascript가 뜨면서 2000년도부터는 폭발적으로 javascript개발자들이 늘어났음.

Enterprise architecture에 빠르게 개발하고 테스트해볼 수 있는 작은 architecture를 MSA(Micro Service Architecture)라고 함.

여러 언어들을 섞어서 개발하는 것을 Polyglot이라고 함.



html+css,js 이분야 개발자들을 frontend개발자라고하고

servelet쪽 개발자를 backend개발자라고 함.

둘다 하는 걸 fullstack개발자라고 함.

Sitemesh, JQuery 이런애들은 CGI쪽에서도 view쪽 역할을 해주는 jsp와 같은 component들을 만들 때 화면을 정갈하게 잘 분리해서 만들 수 있도록 도움을 주는 framework들임.

Spring 3 framework가 core framework

mybatis는 db랑 연결을 편하게 해주는 framework

spring mvc는 spring3이랑 의존성이 있는 framework

grunt,bower,karma,less등등 이런 것들 다 frontend 개발자들을 위한 framework임. 개발자 편의성을 극대화하는 방향으로 만들어짐.

거인의 어깨 위에서 파이썬으로 챗봇을 만들었다고 해보자.

쇼핑몰이었는데 쇼핑몰의 챗봇 시스템을 파이썬으로 개발하면, 자바 개발팀을 데려다가 챗봇 기능을 붙여하면 1달 걸릴 것을 파이썬 개발자들을 데려와서 붙이라고 하면 10일만에 할 수 있음. 업주 입장에서는 파이썬 개발자를 씀. 어떤게 취업이 잘되냐고 물어보면 그래서 파이썬 개발자들이 취업이 잘됨.

파이썬으로 개발되면 파이썬 코드로 짠 것이 컴파일되어 실행될텐데 메모리 객체 쪽으로 들어가지 못함. 그래서 또 새로운 프로세스를 또 만들어야 함. 만약 객체 정보를 받아올 필요가 있다면 서로 다른 프로세스간에 데이터를 받아올 수 있도록 연동해야한다. 이것을 분산 어플리케이션이라고 함. 메모리 스페이스가 다르면 분산이라고 말하는 것. 같은 머신 안에서도 두 어플리케이션이 소통하기 위해서는 소켓을 통해서 네트워크에 길을 열어서 소통해야함. 이 통로를 통해서 1바이트(8비트)씩 이동시킴. 이것을 stream이라고 부름. 바이트가 흘러가는 이런 형태의 서비스를 스트리밍 서비스라고 칭함.

하나의 머신에서도 프로세스가 다르면 네트워크 길을 내서 데이터 이동을 해야한다는 소리. 얼마나 많은 일들을 해야하고, 얼마나 느리겠는가.

개발 해주고 나가는 사람은 10일만에 해주고 나갈 수 있으니까 굉장히 괜찮은 수입이 보장된 것이지만, 남아서 enterprise system을 운영해야하는 운영자 입장에서 보기에는 문제가 생길 수 있다.

이 분야에 대해서 정통한 사람이라면 문제점을 인식해서 빠르게 해결할 수 있겟지만, 그렇지 않은 사람에 대해서는 이런 분야가 너무 복잡해서 취약점이 될 수 있다.

하드웨어(=건물)이라고 표현한건 사람으로보자면 몸에 해당됨. os라고 표현한건 사람으로 보자면 두뇌에 해당됨. 우린 다 두뇌를 가지고 있는데 불구하고 생각이 다름. 생각을 응용 프로그램으로 보는 것.

서버를 운영할 때 실제로 몸을 다 사용하지는 않음. 그래서 70%씩 잉여가 남는 비효율이 계속 생김. 다른 서버에서 돌아가고 있는 생각들을 이쪽에서 하게 하자.하는 아이디어가 생김.(클라우드서비스)

다른 서버는 몸이 다른 것임. 하드웨어가 다름. 두뇌(OS)도 다름.  여기의 어플리케이션 A,B는 이쪽 방식의 0과 1로 구동됨. 이걸 우리쪽에서 수행하려면 많은 문제들을 극복해야함.엔터프라이즈시대가 가속화되면서 서버자원들이 남는 것을 효율적으로 활용하기 위해서, 한대에서 효율적으로 활용하기 위해서 반대편의 H/W와 OS를 쓰는 것처럼 쓸 수 있게 해주는 기술들이 생기기 시작함.

이 위에 프로그램을 깔았음. (VMWare 또는 Virtual Box같은 제품들.) 가상 머신을 돌려주는 Product. 이런 제품들이 생기게 된 덕분에 다른 머신들을 올려놓을 수 있는 형태가 됨.

가상 머신 Product위에 다른 하드웨어, 다른 OS 를 올려서 구동할 수 있게 되었다. 그리고 가상 머신 위에서 구동되는 어플리케이션들이 있다. 위에서 말한 상황을 여기서 가능하게 만드는 것. 분리되어있지만, 한 pc에서 가동된다.

70% 남는 자원을 이렇게 운용하겠습니다. 하는 아이디어가 뜸. 막상 사용해보니 퍼포먼스가 좋지는 않음. 가용성이 좋지는 않네.

시류에 발맞춰 다른 솔루션들이 제시되기 시작함. 가상머신위의 가운데를 비워놓은것은 말하지는 않았지만 다른 stack들이 있을것이기에 비워둔것.

조금 더 성능이 좋으면서 쉽게 환경을 구축할 수 있는 방법. 개발뿐만아니라.(개발환경과 운영환경은 매우 다름) 운영에도 도움이되는.

커다란 게 있다고 하면, 이 안에 서비스를 해주는 엔진을 가동시켜야지. 이것이 도커. 필요로하는 상황들을 컨테이너라고하는 형태로 집어넣어주면 저장하고 있다가 신호를 보내면 그것을 당신들이 다운로드할 수 있게 해줄게요.

컨테이너라고 말하는 것은 Servelet을 실행시킬 수 있는 기반되는 환경인 것.  기반환경을 컨테이너 안에 통째로 넣음.

개발자들 보고 당신이 일일히 다운로드 받을래요 아니면 준비해놓은거 다운로드받을래요하면 무조건 후자임. 이런 개념에서 나온게 도커임.

개발자 편의성을 극대화하는 방향으로 기술이 발전한다는 얘기.

도커엔진위에 도커 컨테이너가 올라가있는 이러한 형태는 도커 레지스트리임.

윈도우즈위에 윈도우즈용 도커를 다운로드 받고 컨테이너를 호출하면 받아서 쓸 수 있음.

근데 처음 만든 사람이 리눅스를 좋아해서 도커 명령어가 리눅스에 최적화되어있음.

윈도우에서 쓰기에는 불편함.

우분투위에서 도커를 설치하면 윈도우에서보다 더 잘 알아들음.

이 도커를 이용해서 서치하라고 하면 신호를 보냄 근데 네트워크 연결이 안되있으면 통신이 안됨.

만약 A라는 컨테이너의 스택이 내가 원하는게 아니었다면,  밑에 스택을 내가 원하는대로 가져와서 쌓을 수 있음. OS부터도 쌓을 수 있음.

무슨 서비스를 할 것인지 정해야 어떤 기술이 필요한지 정의할 수 있음.

노베이스면 아키텍쳐 그리기도 힘듬.

b2b로 api를 사용해서 차트데이터를 받아오는 것도 가능하니 열심히 주차별 교육을 배워서 사용할 수 있도록 해보자!