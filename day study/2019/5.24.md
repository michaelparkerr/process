# Docker 실습의 의미

어떻게 운영 체제 위로 stack 되는지에대한 이해를 돕기 위함.

실행하기 위해서 어떤 환경 변수를 통해서 설정이 되어야하는지를 알 수 있었음.

환경 변수는 절대적이지 않고 유동적임.

이미지를 찾을 때는 그 이미지 레지스트리에 가서 해당하는 이미지의 설명문을 보고 거기서 맞는 환경 변수를 설정하는 활용이 필요함.

``` BASH
- 는 표준 옵션
-- 는 비 공식 옵션
```

이미지가 실행이 되었다면 프로세스가 가동되었다는 얘기. 머릿 속에는 호스트 위에 하드웨어 위에 우분투 위에 MYSQL이 돌아간다고 생각할 수 있어야함. 실제 이게 내 우분투 위에서 돌아가느냐를 확인해야함.

그래서 MYSQL 컨테이너로 들어감. 들어갈 때 attach, 나갈 때 detach

-t 는 tty 리눅스 터미널의 이름

-i 는

-it 옵션을 주면 exit하면 컨테이너가 종료됨.

-it를 줬더라도 exit는 안하고 detach 만 하고싶으면 ctrl+p , ctrl + q를 누르면 된다.

exec  -it로 들어가면 exit로 나가도 종료 안됨.

mysql은 서버와 클라이언트가 분리되어있음.

그림으로 그리자면





左 



Docker左

MYSQL client 5.7, MYSQL server 5.7

클라이언트에서 서버로 접속. DB라고 그림을 그리는 것은 Server에 해당.(원통형으로 그리는 이유는 곡식창고라는 의미에서. 사일러스) show databases로 어떤 DB가 있는지 확인.

Debian 9

Docker右

Docker

Guest OS(ubuntu16.04)

右VM Ware

host(windows)

h/w



docker container 를 stop 시켰다가 start 시키면 원래는 그 안의 data가 날아가야하는데 왜 database가 그대로 있을까? container 안의 file system이 있기 때문이다.

commit은 트랜잭션할 때 사용되는 단어 tranaction은 한번 처리를 할 때의 단위임.

계좌 거래처럼.

계좌에 돈 넣다가 에러가 났으면 돈이 빠지기 전 상태로 복원해야함. 그것을 롤백이라고 함. 커밋을 데이터가 저장되고 보장된다는 것을 보장한다는 명령임.

MYSQL이 메모리에만 있는 것이 아니라 정보들을 파일시스템에 저장해둠. 그 파일시스템을 볼륨이라고 함. 그 볼륨을 빼고 commit함.

볼륨에 들어가는 애들은 빠지니까, 실제 db에서는 이런식의 사용을 할 수 없음. 우리가 작업을 할 때 db에 쌓인 내용들을 그것을 그 위치에서만 사용하는 것이 아니라 내가 사용하던 이 컨테이너를 다시 이미지화해서 레지스트리에 푸시해놓고 이건 개발 머신이었는데 다시 운영 머신에서 그대로의 상태를 동기화 하고 싶을 때 도커를 사용함.

근데 열심히 만든 상태를 다 빼고 그대로 올라가버리면 다시 노가다해야됨. 그래서 볼륨을 어떻게 맞추느냐가 문제.

볼륨이 컨테이너에서 사용하는 파일시스템. 컨테이너가 위치한 곳을 호스트라고 한다면, 그 파일시스템을 마운트 시킴. --volume이라고 하거나 -v라고 하고 앞 부분을 호스트 머신.(우분투) :뒷쪽을 컨테이너의 디텍터리로 지정함.

nginx의 경로를 알아야지 마운트 위치를 지정할 수 있기 때문에 설치 이후 어디에 html을 넣어야 web server에 반영이 되는지를 확인해야함.

컨테이너에 있는 os는 ui가 없다 용량문제 때문.

실제 개발 시점에서 html java등등 엄청나게 작업할텐데 순수하게 vi로 작업한다면 좀 불편함.

그래서 편하게 작업하기 위해 -v 명령어로 마운트시켜서 호스트에서 작업할 수 있도록 하는 것.

요구사항의 방향성은 다르지만 결국 똑같은 방법으로 할 것.

mysql도 이렇게(마운트해서 하는 방식) 가능하다는 것.



ruby의 gem sinatra는 설정파일. 즉 ~~에서 받아서 이렇게 설정하겠다는 의미.

rb는 어떻게 실행할 것인가 결정. 뭐랑 뭐랑 사용하겠습니다.(라이브러리,다운로드받아야하는 라이브러리와 다운로드 안 받아도 되는 기준 라이브러리가 있음)

get '/'은 특별히 자원이 들어오지 않으면 do명령을 실행하겠다고 하는 것.

요즘은 프로그램을 스크립트 형태로 많이 만듬.

쉘을 여러개 쭉 나열해서 쓰는 것을 쉘 스크립트.

노드도 이런 스크립트 형태로 짬.

build 뒤의 t는 tag. -tty가 아님 --tag로도 사용 가능.

태그할때 0.0.0 은 주버전 마이너버전 패치버전 순으로 옴.



원래는 서버 개발하기 위해서는 tomcat server안에서 고쳐야하는데 지금은 mount해두어서 호스트에서 고쳐도 해결가능

5.24 4번 그림

꺽쇠(<>)형태로 표현할 수 있다. 이것을 sterotype이라고 한다.

이해관계에 있는 사람들끼리 알고 있는 것을 명시하는 것.

화살표시를 통해서 서로의 연관관계와 누가 노출되고 누가 숨겨져야하는지가 보여짐.

colorful하게 색깔로도 표현하고 있음. 빨간색 점선은 data 파란색은 web service, 초록색은 message-based integration이다. 중요하게 여겨지는 신호코드들을 넣을수도 있다.

5.24 5번 그림

sun sparc 서버 라고 명시되어있고, 그 안에 schema라는 것이 있음. db안에서의 table을 명시하는 의미임.

앞에는 java기반이어서 sun fire 서버를 사용하고 jsp server를 tomcat 7을 사용하고 아래에 이런 architect들이 생선되서 사용되고 있다. jar를 표현한 것도 한번 봐라. 옆에 있는 것도 jar. 어떤 모양으로 표현해도 상관 없지만, 이걸 그린 사람은 경험적으로 이해되는 수준에서 보자면, 톱니바퀴형태의 jar는 executable 실행가능한 jar 그냥 있는 건 읽고 쓰는 것만 가능한 jar.

방향표시를 잘 모르겠으면 그냥 실선과 점선으로만 얘기함. 점선은 모호한 것. 실선은 명확한 것.

점선은 loose한 coupling. 처음에는 점선을 많이 활용함. 아직 방향성도 명확하지 않음. 그냥 점선만 쓰다가 명확해지면 방향성도 그리고 실선으로 그려라.

디텍터리 안에 word파일이 또 배포되어있음.

architecture diagram 그려보기. 5장의 그림을 참조하여

각 tier와 stack을 표현해보자.

설치했을 때의 diagram

여기까지 했을 때의 diagram 등등..