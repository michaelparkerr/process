9시~10시

proxy 중간에서 요청과 응답을 낚아채서 전달.
burp suite같은 proxy도구에서는 listening을 함.
포트를 지정해서 구동시켜놔야함.(프로그램 실행)

proxy쪽으로 접근하는 사람. 호스트쪽에서 network drive에서 proxy경유한다고 설정해줘야함.(프록시서버설정에 들어가서 LAN 설정 가서 프록시 서버사용 허용해줘야함.)

일반적으로 proxy가 외부에 있을 때는 프록시 사용허용, 주소, 포트번호만 입력해주면되지만

proxy가 내부에 있을 때는 추가로 <고급>설정에 들어가서 예외란에 <-loopback>을 입력해줘야한다.

WebGoat에 접속했을 때 어떤 방식으로 directory 요청을 하고 default page를 보고 derectory listing option을 확인하고 해당하는 사항에 접속하여
인증정보를 입력했을 때 redirect로 연결되는 방식임을 history 탭을 보면서 이해한다.

인증한 뒤에 Authorization이 붙어있는 것을 확인하고, 이것이 인증정보임을 확인하고 BASE64를 이용해 만든 암호임을 이해하고,
이게 취약하다는 것을 이해한다. 매번 인증정보를 표시하기 때문에 유출가능성이 높아지게 된다.(노출이 많아지므로)

form tag의 입력값으로 세션을 만들면 서버가 더이상 인증정보를 필요로 하지 않고 세션정보만을 필요로하는 상황이 훨씬 더 안전하다.

Vmware 직접 설치해서 사용할 수 있으면 해보기(설치해보는것도 실력)

NAT
Network Address Translation 방식은 게스트가 호스트와 별도의 IP의 대역을 쓰게되고, 나갈 때는 호스트 대역을 경유해서 나가지만, 게스트 네트워크 끼리의 통신을 직접적으로 수행할 수 있다.

외부에서 호스트 내부 또는 내부 네트워크로 들어오려고 하면 port fowarding을 사용해야한다.

bridge는 가장 간단한 구조. 같은 대역을 동등하게 사용하는 것. 물리적으로 동일한 호스트가 증설된다고 보면 됨.
이 교육장에서는 임의로 증설할 수 없다.(고정 IP이기 때문에)
집에서는 유동IP이기 때문에 가능.(집에서 해보기)

Internal Network는 Host 포함하여 밖에 나올 수 없음. 내부 네트워크끼리만 통신 가능

Host-Only는 Host까지 접근가능하지만 밖에 나올 수 없음. 내부 네트워크 끼리만 통신 가능

Node는 ES(ECMA Script의 약자임) ECMA Script는 자바 스크립트의 표준이다.

예전에는 변수를 선언할 때 var http; 이렇게 했었는데 ECMA로 넘어오면서 let이나 const를 쓰기 시작.
var는 가급적 안쓰는게 좋다.(다른 것을 권장)

let a=1 하면

a=2; 이렇게 사용 가능(변수 지정)

const b=1;
b=2; 하면 오류남. const는 설정만 할 수 있지 변경할 수 없음.(상수 개념)

const http = require('http');로 http에 있는 기능들을 가져온다.

const server... => 나오는 화살표함수는 빨리 적응해야한다.(요즘 전부 이런 방식으로 표기)(이전 fucntion방식 표기보다 화살표 방식 선호)
함수명을 제거한 function을 anonymous function(익명 함수) 라고 한다.

즉 const server = http.createServer((req,res) => {  // 변수는 req,res 
text/plain 은 별도의 처리하지말고 그냥 뿌려주라는 의미.

만약 cmd에서 node hello.js해서 서버를 구동시킨 뒤 hello.js에서 Hello, node.js를 <h1>Hello, node.js</h1>으로 수정하면 큰글씨로 출력되는 것이 아니라
 <h1>Hello, node.js</h1>으로 그대로 출력된다. 그 이유는 content-type이 text/plain이기 때문이다.

request head의 역할은 서버가 요청을 처리할 때 필요로하는 정보, 참고 하는 정보이다
response head는 브라우저가 주는 정보의 결과를 처리하는데 참고하는 정보이다.

f11에 f5를 해서 나오는 창에서 header와 응답을 봐야 문제를 해결할 수 있다.(client에서 어떻게 처리하는지를 확인.)

---

10시~11시

블록체인 개론
https://myanjini.tistory.com/43
https://myanjini.tistory.com/44
https://myanjini.tistory.com/45

자본주의 1부 - 돈은 빚이다.
http://www.ebs.co.kr/tv/show?prodId=348&lectId=3121167

http://www.yes24.com/Product/Goods/67090202?Acode=101
https://github.com/ethereumbook/ethereumbook

비트코인, 공개 블록체인 프로그래밍 (안드레아스 저) 읽어보기(메인넷 개발 지향자)
http://www.yes24.com/Product/Goods/58149507?scode=032&OzSrank=5

비트코인과 블록체인 탐욕이 삼켜버린 기술(이병욱 저) 읽어보기
코어 이더리움 프로그래밍 읽어보기(박재현 저)(메인넷 개발쪽)
http://www.yes24.com/Product/Goods/59621522?scode=032&OzSrank=1
블록체인 해설서(이병욱  읽어보기
http://www.yes24.com/Product/Goods/69758354?scode=032&OzSrank=2

파이썬으로배운 블록체인 구조와 이론(이광성 저)
블록체인 무엇인가(다니엘 드레셔 저)

하이퍼레저 블록체인개발(니틴 가빈 저)
하이퍼레저 패브릭으로 배우는 블록체인(윤대근 저)
블록체인 혁명(돈텝스콧 저)
블록체인 구조와 이론(아카바네 요시하루 저)
엔지니어링을 위한 블록체인 프로그래밍(다고모리 데루히로 저)(곧 줄거임 이 책은)

이더리움 Dapp쪽 개발 추천서적

블록체인 애플리케이션 개발 실전 입문(와나타베 마츠시, 마츠모토 유타 저)



비트코인에서 시작되었기 때문에 비트코인을 먼저 본다.

비트코인 탄생 배경
서브프라임 모기지
무정부주의 사이버펑크 운동
컴퓨터 공학 및 암호학적 발전
사토시 나카모토 비트코인 백서 2008.11.1

비트코인
중앙기관 없이 네트워크 참가자간 P2P 방식으로 발행, 유통되는 전자 화폐
2140년까지 2100만개 한정된 발행량의 디플레이션 화폐
모든 비트코인 거래 내역은 블록체인이라 불리는 공개분산장부에 기록
위변조 불가능한 공개분산장부를 통해 신뢰하지 않는 주체간 안전하고 효율적인 거래 가능
최근에는 분산원장이라는 말을 더 자주 사용하고 있음


이전에 해결할 수 없던 문제들
1. 자율적으로 유지되는 네트워크 활동과 추진력(확산이 되지 않음)
책임있는 관리자 없이 시스템 품질(복원성, 가용성)을 유지하면서 운영하지 못할 수 있다.
2. 악의적 참가자에 의한 부정, 위변조
누구나 참가할 수 있는 네트워크에서는 의도적으로는 부정한 거래를 만들거나 거래 결과를 자신에게 유리하게 변경하는 악의적인 참가자가 있을 수 있다.
3. 정보 전달의 지연으로 인한 불일치
실행된 거래의 결과가 늦게 전달, 공유되어 이중 지불과 같은 불일치 상태가 발생할 수 있다.

해결책1. 악의적인 참가자에 의한 부정, 위변조

참가자의 본인 인증과 부인 방지
-참가자 개인키를 이용한 전자서명
악의적인 참가자에 의한 부정 방지
-네트워크 참가자 전원이 모든 거래 이력을 기록한 장부를 공유
거래 내역 위변조 방지
-거래 내역을 담은 블록을 생성할 때 이전 블록의 해시를 포함
블록 전체에 대한 위변조 방지
-새로운 블록을 만들 때 계산량이 큰 문제를 풀도록 함.


참가자 본인인증과 부인 방지를 위한 방법

해쉬는 단방향, 암호화와 복호화는 양방향.
해쉬는 Plain text원문으로 A를 거쳐 Encrypted Text(P) 해쉬를 뽑아낼 수는 있지만, E(P)로 P를 얻을수는 없다.

키를 기준으로 분류하는 기법은 2가지
1. 대칭키 : 암호화와 복호화에 사용하는 키가 동일한 것. -> 기밀성만 제공함. 유일키. 암호화 방식 다른 사람이 알면 안됨. 비밀키. 관용 암호화 방식.
2. 비대칭키(공개키 암호화 방식) : 암호화와 복호화에 사용하는 키가 다른 것. -> 키를 분배하고 관리하는 방식에 문제가 있음.
A가 생성한 데이터를 B에게 전달할 때 이 데이터를 다른 사람이 보는 것이 싫은 상황. 데이터를 E(data) 암호화해야한다.
Key를 B에 전달해야만 B가 암호문을 읽을 수 있는데 분리되어있는 네트워크 환경에서 어떻게 전달해야할까? 이것이 키 분배의 문제.

Key 관리의 문제.
상호 배타적으로 문제를 처리하기 위해 B와 통신할 때와 C와 통신할 때 사용하는 Key가 달라짐.
통신 대상이 많아질 수록 관리해야하는 키가 많아진다. 이것이 Key 관리의 문제.

이 두가지 문제점을 해결하기 위해 나온 것이 비대칭키이다. 
키쌍을 만듬. (공개키와 개인키로 나눠져있음.)
여기서 공개키는 다른 사람에게 공개해도 됨.
공개키로 암호화 한것은 개인키로 복구, 개인키로 암호화 한것은 공개키로 복구.

즉, A가 Private키와 Public키를 만들고, 외부 키저장소에 Public키를 저장한다.

그래서 A는 A public key, A private key, B public Key 3개의 키를 갖게 되었다.
B의 공개키를 공개키 저장소에 저장하면 된다.
A는 A의 개인키, B는 B의 개인키, C는 C의 개인키만 잘 관리하면 되게 되었다.

수신자의 공개키로 암호화하고 수신자의 개인키로 복호화한다. <<<<--- "기밀성 보장" 기능이다.
받는 사람만 풀어볼 수 있도록 만들면 됨.
A의 Private키로 암호화하면 A의 Public key로 복호화할 수 있다.
송신자의 개인키로 암호화할 때 송신자의 공개키로 복호화 함으로써 인증, 부인방지, 원본 증명이 된다.

비대칭키가 나옴으로써 A의 Secretkey를 B에게 안전하게 전달할 방법이 생긴 것.
Bpub key로 암호화한 A의 Secretkey를 공유해주면 B는 그것을 B의 Secretkey로 복호화하여 A의 Secretkey를 알 수 있게 된다.

---


11시~12시

SSL(Secure Socket Layer), HTTPS
클라이언트와 서버간의 키 교환을 한다.A가 가진 비밀키를 상대가 비대칭키를 이용해 가질 수 있게 된다.
A에서 B로 이체를 요청할 때 이체 정보는 다른 사람이 알면 안됨.(은행만 알아야함.)
그리고 은행입장에서는 진짜 A가 요청한 것인지 알아야함.

1. A가 요청한 것인지 증명하고
2. 다른 사람이 알면 안됨.

이체 정보를 A가 갖고 있는 개인키로 암호화하고, 은행이 보관하고 있는 공개키로 암호화한다.
B는 역으로 자신의 개인키로 복호화하고 A의 공개키로 복호화한다.
B Pub [ A pri(정보) ] -> B pri -> A pub

송신자가 개인키로 암호화 하는 것을 '서명'한다고 함.
받는 쪽에서는 그게 풀리는지 안 풀리는지 확인한다.('서명 검증' 이라고 함)

추가로
A가 만든 시점의 데이터와 일치하는지 확인하고 싶을 때 어떻게 해야할까?
해쉬의 특징 무결성을 이용한다.

A (data) -> B (data') ->H(data')
H(data)  -> H(data)
H(data')과 H(data)를 비교하여 무결성 검증한다.

이 과정에서 문제가 생길 수 있는데 중간 과정에 제3자가 개입하여 데이터를 바꾼다면?
data를 X로 Hash를 H(X)로 바꿔서 전달한다.
그렇다면 B는 X를 해쉬화 했을때 H(X)이므로 속을 수 있다.
그러므로 이 문제를 해결하기 위해 A private key [A(data), H(data)]로 A로 개인키로 암호화하여 전송하면된다. B가 갖고 있는 A의 공개키로 검증했을 때 안되면 변조된 데이터임을 확인할 수 있다.

또 다른 문제가 발생할 수 있는 것은
X가 A인척 하는 것이다.
공개키 저장소에 저장되어있는 A의 공개키를 참고하여
A' pri [ X(data), H(x) ] 로 변조한다면?
key를 제 3자가 보증해주어야한다.
이것을 PKI 체계라고 한다.Public key Infrastructure. 제 3자가 키를 보증해주는 것.
하지만, 보증의 보증을 위조할 수 있으므로 결국 다단계 방식으로 가장 위에서 보증해주는 기관이 있어야함.
우리나라는 KISA가 보증해줌. 이것을 RootCA라고 함. 이것이 국가 기관일 때 이것을 공인인증체계라고 칭한다.
즉 보증을 위한 기관이 신뢰할 수 있는 기관이어야 한다.

비 대칭키의 문제는?
연산속도 문제(대칭키의 1000배 느리다.)
해결하는 방법은 데이터 암호화는 대칭키를 활용, 대칭키는 비대칭키를 활용하여 해결할 수 있다.


악의적인 참가자에 의한 부정 방지를 방지하기 위한 방법

장부 공유를 통한, 분산원장.


거래 내역에 대한 위변조 방지 방법

이전 거래 내역의 요약이 포함된 해쉬를 포함하여 다음 장을 시작해야하기 때문에 중간에 내역을 변경하기 힘듬.



블록 전체에 대한 위변조 방지 방법

부지런한 사람이 혹시나 바꾸려고하더라도 문제를 풀어야만 페이지를 작성할 수 있도록 해둠.
수학적으로 변조 속도가 새롭게 생기는 속도를 따라가지 못하도록 만듬.




해결방안2. 정보전달의 지연으로 인한 불일치

이중 지불(사용) 여부 보증 및 확인

네트워크 참가자 전원이 모든 거래 이력을 기록한 장부를 공유

P2P 네트워크에서 블록체인 분기 문제 해결
가장 긴 블록체인을 채택한다.

거래가 보장되어야함. 보장되지 않은 거래는 쓸 수 없기 때문이다. 이것을 확정성이라고 함.



해결방안3. 네트워크를 자율적으로 유지, 운영하기 위한 추진력

막대한 CPU 파워에 대한 부담
->블록을 만든 사람에게 보상

---

13시~14시

0101로 움직이는 네트워크에서 전달하기 위해서는 일정 규모로 잘라서 데이터를 보낸다.
잘라서 보내야 이득이 있기 때문, 만약 통으로 보냈을 때 전부 다 잘 전송됬는데 마지막 1byte가 잘 전송안됨으로써 에러가 발생할 수 있기 때문에
잘라서 보내고 받아서 재조합하는 방식으로 데이터를 전송한다.(유실되거나 손실되는것이 적어짐)
또한, 문제가 생겼을 때 유실되거나 손실된것만 다시 받아서 사용하면 됨.

패킷에서 IP header는 TCP에서 flag에서 

http에서 요청과 응답하는 데이터는 data에 붙는다.

packet의 이미지 보고 살펴보기.

destination에 내가 아닌 것이 들어오면 그대로 흘려보냄.
또는, destination이 어디인지 물어볼 수 있음. broadcasting하는 것이나 자신을 타겟으로 잡아서 들어오고 나가는 것을 전부 와이어샤크가 잡아낼 수 있음.
burp suite는 http의 데이터를 보기 좋게 해주는 것이다.

burpsuite는 버전이 여러개 있는데, enterprise, professional, community이있다. 가장 기본적인 기능은  모든 요청과 응답을 intercept하는 것이다.
또한, history 관리를 해서 추적할 수 있다. 또한, 공격에 재활용할 수 있다.
기본적인 툴에서 분석하고 재조합해서 무작위 대입공격같은 공격방식에 대한 툴도 제공한다.

이더넷에서는 tcp port = 80으로 검색하여 포트 80번인 것들을 찾아낼 수 있다.

syn ack하는 것은 443->59026으로 443이 싱크해서 59026에게 ack하는 것이다. 그러면 443과 59026은 연결이 된 것이다.

가상환경에 와이어샤크를 깔아서 한놈하고만 통신하는 과정을 살펴볼것(나중에)

와이어샤크는 packet catching,packet sneeping 도구이다.



비트코인이란?

거래

1. 한 사용자가 다른 사용자 계좌로 송금주문을 넣음
2. 해당 주문은 채굴되기 전 네트워크에서 대기

채굴

3. 주문들은 헤더와 함께 블록화되어 채굴자들에게 전달
4. 블록의 해쉬값을 먼저 찾기 위해 경쟁
5. 해쉬값을 가장 먼저 찾은 채굴자는 새로운 비트코인을 얻음.
6. 채굴자들이 찾은 해쉬값은 그 다음 주문의 블록에 들어가서 블록체인을 형성

주문에는 공개키와 비밀키, 그리고 가상지갑으로 거래를 인증할 프로그램이 필요.


공인인증서에서 마지막 입력하는 비밀번호는 개인키를 암호화하는 비밀키이다.
비밀키를 입력->암호화되있던 개인키가 복호화->그 개인키로 전송할 데이터를 암호화.


이더리움 client = term 그 자체가 용어임. 이더리움에 물려있는 단말(다른 곳에서 node,peer라고 칭함)
transaction이 발생하면 그것이 비트코인 네트워크로 전송되고
이것이 각 노드 개별의 transaction pool에 트랜잭션이 쌓이고 블럭을 만든다. 블럭을 만드는 과정에서 문제를 푸는 과정을 채굴이라고한다.
가장 문제를 먼저 푼 사람이 풀었다는 것을 broadcasting하고 체인을 붙인다.
만약 늦게 문제를 푼 사람이 다른 것을 broadcasting하면 먼저 broadcasting된 것을 우선하므로 배제된다.


비트코인의 한계점

1. 계속 발행할 수 없다는 점.
2140년 채굴보상의 종결과 수수료만으로 채굴보상이 유지될 것에 대한 의문점

비트코인 정의

위키피디아 : 분산 컴퓨팅 기술 기반의 데이터 위변조 방지 기술
옥스포드 사전 : 비트코인 혹은 다른 암호화폐의 거래가 순차적이고 공개적으로 기록되는 디지털 장부
영국정부의 블록체인 보고서
분산장부는 기본적으로 자산의 데이터베이스이다. 이데이터베이스는 여러 시스템, 구성원, 기관들로 구성된 하나의 네트워크 상에서 공유될 수 있다. 네트워크의 모든 참여자들은 각자 자기 고유의 장부 복사본을 가질 수 있으며, 공유된 장부에 어떤 변경이 발생하면 그 내용은 모든 장부에 몇 분 내지는 몇초만에 반영된다. 장부에 기재된 에셋은 금융적, 법적 물리적 또는 전자적일 수 있다. 장부에 기재된 에셋의 보안성과 엄밀성은 전자키와 전자서명에 의해 암호학적으로 유지되는데, 이것들은 고유된 장부 내에서 누가 무엇을 할 수 있는지를 통제하는 수단이 된다. 새로운 등재 내용은 하나, 여럿 또는 모든 참여자들에 의해서, 네트워크에 의해 동의된 규칙에 준거해 업데이트될 수 있다.
딜로이트 : 서로 알지 못하는 사람들이 공유된 거래 기록을 믿을 수 있게 해주는 기술
기술의 총합이면서 공유된 기록 그 자체 또는 장부인 블록체인은, 특정한 네트워크 상에서 모든 참여자들에게 분산되어 있으며 참여자들은 자신들의 컴퓨팅 자원을 이용해 거래기록을 유효화하고, 이를 통해 제 3기관의 개입을 불필요하게 만든다.

---

14시~15시

한국은행 : 분산원장(Distributed Ledger) 기술
거래정보를 기록한 원장을 특정 기관의 중앙 서버가 아닌 P2P 네트워크에 분산하여 참가자가 공동으로 기록하고 관리하는 기술
금융위원회/금융감독원 : 블록체인이란 거래 데이터를 중앙집중형 서버에 기록, 보관하는 기존 방식과 달리 거래 참가자 모두에게 내용을 공유하는 분산형 디지털 장부를 의미
금융결제원 : 블록체인이란 분산된 네트워크의 컴퓨팅 자원을 모아 거래한 연산 능력을 확보하고, 이를 기반으로 중앙서버 없이 모두 작업을 처리하고 검증하는 기술

William Muogayer, 2016
1. 기술적 측면
블록체인은 공개적으로 열람 가능한 분산 원장을 유지하는 백엔드 데이터베이스
2. 비즈니스 측면에서,
블록체인은 중개자 없이도 개인(peer)간의 거래, 가치, 자산등을 이동시킬 수 있는 교환 네트워크(exchange network)
3. 법적 관점
블록체인은 거래를 검증해주므로 종전의 신뢰 보증 기관을 대체하는 수단

블록체인 기술의 장점
보안성 향상
중앙 데이터베이스 한곳에 모든 자료를 저장하는 것 보다 데이터 손실에 대한 위험이 낮음
중앙 집중화된 시스템 관리가 필요하지 않으므로, 내부자에 의한 조작 또는 정보 유출 위험이 크게 감소
암호화된 데이터와 암호화된 키 값으로만 거래가 이루어지므로 보안성을 높일 수 있음
새로운 블록은 기존의 블록과 연결되므로 전체 블록 안의 데이터 변조와 탈취가 불가능
각 참여 노드의 분산화로 해킹이 불가능

안정성 향상
일부 시스템에 오류 또는 성능저하가 발생하더라도 전체 시스템과 네트워크에 영향을 미치지 않음.

거래 속도 향상
거래의 인증, 증명 과정에서 제 3자를 배제시키는 실시간 거래가 이루어지므로 거래 기록의 신뢰성 확보와 동시에 거래의 효율성 및 속도가 향상됨
분산원장 기술로 실수를 최소화시킬 수 있으므로 오류의 정정과 수정을 위한 시간이 줄어 듦.

비용 감소
중앙 집중화된 시스템이 필요 없기 때문에 비용이 적게 듦.
참여자간 직접 거래로 중개 수수료를 절감.

거래 투명성 향상
모든 참여자들이 거래 장부를 공유하고, 거래 장부에 접근이 가능
네트워크 참여자의 실시간 모니터링이 가능.

블록체인 기술의 단점
처리 속도
시간당 거래 처리속도(tps)가 제한적

저장 공간
모든 거래 기록을 저장해야 하므로 저장 공간이 점점 증가

일반적으로 network단에 물려있는 것을 server라고 한다. 그런데 블럭체인쪽에서는 server라는 얘기는 잘 안쓴다.(중앙 통제기관처럼 느껴지기 때문에)peer나 node를 씀(이더리움은 client)
블락이 있을 때 이전 블록에 대한 전체 요약이 들어감(이전블럭hash) 다음블럭에도 이전 블럭hash의 요약.

------

15시~16시

중앙집중형 네트워크가 있고 분산형 네트워크가 있다(Distribute Network).
분산형 네트워크는 Public과 Private 2가지가 있다.

Public 누구나 네트워크에 참여가능(트랜잭션 만들고,블럭만드는등)(사람이 아니라 장비로서의 의미, 어떤 장비를 연결해도 다른 장비와 동일하게 작동함을 의미)
Private 제한된 인원만 네트워크에 참여가능(노드로서, 사람의 의미가 아님)

(사진찍어둠) (Public과 Private과 Consortium 설명)

finality(확정성, 최종성) 거래가 끝났다를 보장해주는 것. public체인에는 없다.

Public Blockchian
Permissionless
네트워크 참여에 제한이 없음
누구나 블록체인 데이터를 읽고, 쓰고, 검증할 수 있음
예 : Bitcoin, 암호화폐

단점 및 제한
돈 세탁이나 밀수품 거래 등에 악용될 수 있음
블록체인을 유지하려면 경제적인 인센티브가 필요(예: 채굴)
블록체인 프로토콜을 변경하기 위해서는 참여자의 51% 이상이 동의해야 하므로 어려움

Private Blocchain
Permissioned
단일 조직에서 운영
읽기, 쓰기, 합의 과정에 참여할 수 있는 참여자가 미리 지정
중앙 기관 한 곳이 모든 권한을 가지며, 네트워크에 참여하기 위해서는 해당 중앙 기관의 허가가가 필요
예: 은행간 지급 결제 네트워크

장점
느린 거래 속도와 네트워크 확장성 문제 해소
Public Blockchain의 단점이나, 위험성을 보완

Consortium Blockchain
여러 조직에서 운영
여러 기관들의 컨소시움으로 구성하는 블록체인
미리 선정된 노드에 의해서 컨트롤되는 반 중앙형 블록체인
미리 선정된 노드들이 권하을 가지며, 노드간 동의가 일어나야 거래가 생성
예 : 공급망, 주로 엔터프라이즈 영역에 적용

장점
분산형 구조를 유지하면서 제한된 참여를 통해 보안 강화
네트워크 확장이 용이하고 거래 속도가 빠름

데이터 입력에 대한 부정이 없는 것이 가장 중요함.(자동화 되어야함. 사람이 개입되어야함.)(그래서 IoT와 묶임)

Tmax는 운영체제를 만드는 회사
발표를 할때마다 죽음 섣불리 하기는 어려움(메인넷 만드는 것은 고난이도)

Solidity와 같은 환경에서 구동되는 Dapp의 개발자

smartcontract code보다 web code 만드는게 더 어려움(UI 만들기 어려움)

블록체인 서비스 기획자들을 많이 찾고 있음.

블록
유효한 트랜잭션 정보의 묶음
비트코인 블록 하나에 포함된 트랜잭션 개수 : 평균 1,400개
비트코인 블록 하나의 크기 : 평균 1.14MB
블록 높이 : 제너시스 블록(0) 이후 블록이 추가될 때마다 1씩 증가
블록 깊이(=confirm) : 블록(1)이 만들어진 후 새로운 블록이 추가될 때마다 1씩 증가

구성 - 블록헤더(80byte),블록바디
블록헤더 명칭(위의 5개는 해시가 나오는 순간 이미 결정되는 값이고, 난스만 바뀐다.난이도 목표를 맞추기위해서)
버전 : 데이터 구조의 버전
이전 블록 헤더 해쉬 " 블록의 체인구에서 이전블록(부모블록)에 대한 해쉬 참조 값
머클 루트 : 해당 블록에 포함된 거래로부터 생성된 머클트리의 루트에 대한 해쉬(블록에 들어있는 모든 거래의 요약본)
타임스탬프 : 블록의 생성 시간
난이도 목표 : Bit 값으로 블록의 작업증명 알고리즘에 대한 난이도 목표(일정 크기이하 값이 나오도록 난스가 조정되야한다.)숫자 앞에 0이 붙을 수록 작은 숫자가 나온다(0010, 0100, 1000) 즉 0을 포함한 것을 찾는다는 것도 결국 같은 표현
난스(nonce) : 작업증명 알고리즘에 사용되는 카운터(난이도가 올라가면 난스 값을 찾는 것이 더 어려워진다.이 난스를 찾는것을 작업증명이라 한다.)
블록바디 명칭
트랜잭션 카운트 : 블록에 포함된 트랜잭션 개수 (1~9byte)
코인베이스 트랜잭션 : 블록 생성시 발생되는 비트코인. 해당 블록을 마이닝한 마이너의 수입(받을 계정 주소)(이더리움에서는 이더베이스(etherbase)라함)
트랜잭션 : 10분동안 수집한 트랜잭션 정보

블록크기(4byte)

블록헤더
버전(4byte)
이전 블록 헤더 해쉬 (32byte)
머클루트(32byte)
타임스탬프(4byte)
난이도 목표(4byte)
난스(nonce)(4byte)

블록바디
트랜잭션 카운트(1~9byte)
코인베이스 트랜잭션
트랜잭션
...
트랜잭션

와 같이 연결되어있음.



블록 해쉬
블록의 식별자
블록 헤더 정보를 SHA256 해쉬 함수로 계산한 32바이트 길이의 숫자

개별거래 
From : 일이삼 To : 사오륙 Amount :2000000 BTC 개별거래의 해쉬값 a7bfd281e...
From : 칠팔구 To : 영일이 Amount :2000000 BTC 개별거래의 해쉬값 b17asdi91...
개별거래의 해쉬값을 합쳐서 머클트리의 해쉬값이 나온다 947c3dafe...
블록헤더 : 버전,이전블록헤더해쉬,머클루트,타임스탬프,난이도목표,난스로 구성
블록바디 : 트랜잭션 카운트, 코인베이스 트랜잭션, 트랜잭션...



블록체인
블록이 이어져서 만들어진 블록의 집합체
블록으로 이루어진 링크드 리스트

제네시스 블록의 이전 해쉬는 0
그리고 제네시스 블록의 해시가 첫번째 블록의 이전 해쉬 값이 된다. 반복..


머클트리(Merkle Tree)
1979년 랄프 머클에 의해 개발된 이진 해쉬 트리 구조
리프 노드를 두개씩 짝지어서 해시값을 만들고 이렇게 만들어진 해시값을 또 다시 두개씩 짝지어 반복적으로 해시값을 생성(리프 노드의 개수가 홀수라면 마지막 리프 노드를 복사해서 짝수로 만듦)
규모가 큰 데이터 집합의 완전성을 효율적으로 요약, 검증하는데 사용
머클루트만으로 트랜잭션의 유효성을 보장 -> Hk 노드 검증은 HL HIJ HABCDEFG 만으로 가능


트랜잭션
비트코인의 거래내역
거래후남은 잔액이 비트코인이므로, 비트코인의 거래내역을 기록한 트랜잭션이 곧 비트코인이 된다.

코인베이스 트랜잭션
블록을 채굴한 사람에게 보상금을 지급해주는 트랜잭션
이전 출력(지급)이 존재하지 않음(보내는 사람이 없다는 의미)(시작이 없음)(받는 사람만 있음)
100 확인(confirmation) 이전에는 사용할 수 없도록 제한

일반 트랜잭션
코인베이스 트랜잭션을 제외한 모든 트랜잭션



UTXO(Unspent Transaction Output: 미사용 출력)
암호화폐를 저장하는 자료구조
출력(지급)은 됐으나 아직 당사자가 사용하지 않은 상태로 블록에 흩어져 있는 기록
당사자만 쓸 수 있도록 잠금 장치 = P2PKH(Pay-To-Public-Key-Hash)

Transaction 0(TX 0)

100,000 satoshis -> input0

TX 0 output 0-> TX 1 input 0(40000satoshis)
TX 0 output 1-> TX 2 input 0(50000satoshis)
로 흩어지다가 다른 트랜잭션으로 이동하지 않은 상태를 UTXO라 부른다.


UTXO 특징
다른 사람에게 일정량의 암호화폐를 받을 때 생성
받은 금액 그대로를 UTXO에 저장
UTXO 안 일부 금액을 송금할 때는 새 UTXO를 생성하고 기존 UTXO는 파기

UTXO를 이용한 송금

거래110
입력100->출력100 (A의 공개키(주소)로 이용권한을 잠금[A의주소-A의공개키])
->A의 개인키로 100에 대한 이용권한을 획득 후 거래(송금)[A의 개인키]
거래 111
입력 100 -> 출력 50(B의 공개키(주소)로 50에 대한 이용권한을 잠금[B의 주소-B의 공개키,B의 개인키]) 출력 50(A의 공개키(주소)로 50에 대한 이용권한을 잠금[A의 주소-A의 공개키,A의 개인키])

https://lisk.io/academy/welcome-to-the-lisk-academy
잘 되어있음 리스크에서 배워보기

Julius Caesar Encryption
3~4글자 뒤로 당겨서 쓰기 H->I 이런식

대칭키 암호화의 예 AES, SEED,ARIA

기존 사용하던 DES가 AES로 대체됨.(안전하지 않기 때문에 대체됨.)

AES가 나오기까지 손놓고 있을 수 없어서 2DES,3DES(=TDES)를 사용했었음.

SEED,ARIA는 우리나라에서 만든 것.

비대칭키 암호화 알고리즘
RSA(소인수 분해가 어렵다는 것을 기반으로 만들어진 암호화,아직까지도 사용중),ECC(타원곡선형 알고리즘,이산 대수의 어려움을 가지고 만들어짐,사물인터넷쪽에서 경량화된 암호화 알고리즘이 필요해서 쓰이고 있음.),DE

전자서명
공개키 시스템에서 송신자의 신원을 증명하는 방법
송신자가 자신의 개인키로 암호화한 메시지를 수신자가 송신자의 공개키로 해독
신뢰성, 무결성, 부인방지

해쉬함수
임의 길이의 데이터를 고정 길이의 데이터로 매핑하는 함수
일방향성 : H(x) = h를 만족하는 임의의 x를 찾는 것이 불가능
충돌회피성 : H(x) = H(y)를 만족하는 임의의 x,y를 찾는 것이 불가능(=유일성)

노드는 트랜잭션을 배포함과 동시에 채굴을 통해 Block을 만들고 발견한 블록을 Broadcasting한다.

해쉬함수
SHA-256(Secure Hash Algorithm 256 bit)
미국 NIST가 개발하여 연방정보처리표준 FIPS 180-4로 표준화한 SHA-2 규격의 일부
256비트(32바이트) 길이의 해시값을 생성

RIPEMD - 160(RACE Integrity Primitives Evaluation Message Digest 160 bit)
1996년 벨기에의 루벤 카톨릭대학교에서 한스 도버틴(Hans Dobbertin)이 개발한 해시 함수
RIPEMD의 최초 버전에서 해시값이 128비트였던 것을 160비트(20바이트)로 확장하고 개량한 것

HASH 160
SHA-256으로 생성한 해시값을 한 번 더 RIPEMD-160으로 해싱한 것

https://www.fileformat.info/tool/hash.htm
SHA-256
a->ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb
A->559aead08264d5795d3909718cdd05abd49572e84fe55590eef31a88a08fdffd
RIPEMD-160
a->0bdc9d2d256b3ee9daae347be6f4dc835a467ffe
A->ddadef707ba62c166051b9e3...

nonce

difficulty

분산에서의 합의 부터 월요일