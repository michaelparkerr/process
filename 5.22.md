전은수 선생님

아키텍쳐에 대한 그림을 그릴 수 있어야함.

computing paradigm의 변화 it기술의 변화

무엇을 중심으로 해서 바뀌고 있는가?

개발자 편의성을 중심으로해서 바뀌고 있다.

사용자 편의성과 개발자 편의성 중 개발자 편의성 중심이라는 것이 증명되었다.

# 1. Program 기법 측면
그 이전 0과 1

- 1950년대 코볼 포트란 베이직 C 절차 중심적 기법
- 1960~70년대 효율적 데이터 관리를 위한 기법이 필요해짐. 정보공학 기법(DBMS)
- 1980년대 산업혁명 시대. 한달 두달 밤새서 고생하지 않도록 빠르게 적용가능한 방법이 필요해짐. 사람이 생각하듯 프로그램하는 것이 중요해짐. 사람의 사고를 컴퓨터처럼 바꾸는데 오래걸리는 것을 개선하는 것이 필요해짐. 그래서 나타난 것이 객체지향 기법.(small talk)
- 1990년대 JAVA를 통한 객체지향 기법 세계화. (객체는 키보드 자판 키 하나하나를 의미)(키가 고장나면 왜 더 싼 키 하나를 바꾸지 않고 키보드 전체를 교환할까? 키 하나를 교체하는 것이 어렵기 때문)
- 2000년대 큰 형태의 객체의 묶음을 만들어야겠다. 컴포넌트 지향의 개발 기법. CBD(Component based development) 기법.

객체지향은 객체라고 하는 말 자체가 reuse 재 사용을 떠올려야함.
왜 다시 사용해야할까? 두번 일하지 않기 위해서.
절차지향이던 객체지향이던 일반 사용자는 관심도 없고 알 수도 없음.
기술이라고 하는것은 개발자들이 퇴근시간을 앞당기기 위한 요구사항인 것이고 그것을 위해 발전하게 됨.

좀 더 기능적인 측면으로 구조화해놓은 것이 component.

- 2005년대 framework 기반의 개발 기법이 부상하기 시작.

framework는 틀이라는 뜻. 대부분의 개발자들이 component와 framework를 구분하지 못함.
component는 기능. framework는 틀.

쇼핑몰을 만들 때 회원가입, 구매는 고객 관리 component. 구매 component이다.
쇼핑몰을 만들 때 나혼자 사용할 프로그램이면 stand alone program
같이 써야지하면 cs프로그램
많이 같이 써야지 하면 web 
전원 나가도 데이터가 남아있어야 해서 db

이와같이 구조가 바뀌면서 항상 해야하는 코드들이 있는데 항상 적용하기 귀찮음. 그래서 생긴 것이 framework.
구조적인 것을 하기 위해서 늘 들어가야하는 code들. 몇줄안되지만 매번 적용하기 귀찮아서 생긴 것이 framework이다.

2000년대 중반부터 엄청나게 많은 framework들이 생겨나기 시작.
하지만 이런 framework들이 구조를 편안하게, (튼튼하게는 아님) 만들어주는 목적이지만, 틀이 허약해지는 경우가 많다.

예를들어 db연결 코드를 5줄을 써야 한다면, db연동 framework를 쓰면 내 눈에 보이지 않게 25줄이 생김.
하지만 개발자들은 25줄이 더 생긴다는 것을 모름.(퇴근에만 관심있음.)

운영자들은 프로그램 세계를 모름.
전문가가되면 depth가 깊어져서 다른 사람의 분야를 이해하기 힘들어짐.
운영자들은 제대로 돌아가지 않는 이유를 추적하게 되는데 그게 결국은 프로그램 문제의 귀결.
그 프로그램 문제가 결국 구조의 문제라는 것도 찾아냄.
하지만, 걷어낼 수가 없음. 그래서 다시 처음부터 짜야하는 경우가 생김.(엔터프라이즈상황에서)

frame work가 이런 이유에서 위험하지만, 다들 보안 전문가가 아니기 때문에 위험하다고 얘기를 안함.

효율성만 쫓는게 아니라(퇴근시간 효율성) 튼튼해야한다.

frame work는 생산성을 위해서 꼭 필요한 도구.
framework 없이는 수많은 사람들이 대형 프로젝트에서 연계해서 일하기 힘들다.
개발경력 3~5년밖에 안된 사람들이 들어와서 enterprise시스템을 구축하려고한다.
그들이 아는 것은 framework 사용밖에 없다. 딱한 상황.

- 2010년대 functional program 기법이 등장. 함수형 프로그램 기법.

여기서는 java가 아니라 java script 공부.
지금은 객체 지향시대가 지고 functional이 뜬게 아님.
두개가 혼재되어있음.

java는 web을 타겟으로한 범용 언어임.
거기서 강자일 수 밖에 없음.

enterprise system은 java를 기반으로 할 수 밖에 없음.
뒤집어지려면 시간이 걸림.

사람들의 저장된 데이터를 가지고 다시 돈을 만들고 싶어짐.
그게 빅데이터.

돈을 버는 사람은 아이디어를 가진 사람. 데이터 분야는 더 함.
기술은 그 돈의 일부를 받을 뿐.

비즈니스를 기술 취합해서 빠르게 해야하는 상황에서는 java. 즉 enterprise 서버 구축하듯이 만들면 집에도 못가고 잠도 못잠.

내 아이디어가 실현가능한지 만드는 수준은 1년~1년반 걸리고 그러면 안됨.(빨리빨리)

현대카드에서 6~8개월 프로젝트가 늦어졌을 때 기사가 난적있었는데 바로 다 내려버렸음.
그래서 일반인들은 다 잘 되고 있는 줄 알고 현실적인 것을 받아들이기 힘듬.

enterprise java 기술을 가지고 스팟성 프로젝트를 진행하기는 힘들다는 것.
그래서 빠르게 진행할 수 있게하는 것이 필요.

양으로 봤을 때는 스크립트 개발자들이 훨씬 많음

그래서 functional language가 뜨기 시작함.

오라클이 java를 먹고나서 그걸로 온 세상을 먹기 위해서 데이터도 분석하기 위해서  기능을 이중으로 개념도 이중으로 하기로 함.

java가 객체지향을 고수함으로써 얻는 이득이 얼마나 많은데 그것을 포기하면 안될 것이다.

java는 enterprise시장에서 묵직하게 있자. 하는 발언이 힘을 얻음.

java8버전에부터는 functional하게 갈것이다. 해서 달라지기 시작.(애매모호한 개념이 되어감)

개발자들이 빠르고 편안하게 개발할 수 있는 방향으로 시대가 움직이고 있음.

어떤 것을 선택하고 버려야할지 그것에 대한 기준은 개발자 편에 있다.

사용자들이 편하게 생각할까? 그건 부차적인 문제. 사용자들은 블록체인인지 아닌지도 모름.

개발자와 사용자는 완전히 분리해서 생각해야 한다.

**시간이 지나면서 추구하는 것은 개발자 편의성이다.**

# 2. 구조적 측면

냉장고처럼 생긴 main frame에 여러가지가 달라붙은 형태였음.

하지만 결국 컴퓨터 1대와 다른게 없기 때문에 변화가 필요했음.

그래서 workstation 이 생겨서 가격도 줄이고 크기도 줄여서

desktop 시대가 도래함.

desktop시대에서는 장점이 내가 원하는 프로그램과 데이터를 내 마음대로 적재시켜놓고 사용할 수 있다는 것이다.

하지만, 문제는 기업용 데이터나 프로그램을 사용할 때는 내 컴퓨터의 사이즈가 작아서 해결하기 힘들어진다.

그래서 다시 client와 server를 분리.

기업용 프로그램이 올라와있는 

DBMS와 client가 db만 주고 받고

client와 server가 정보를 주고받는 방식으로 됨.

여기서 사용되던 프로그램이 다른 곳에서는 사용 못하는 상황이 생김.

그래서 매번 다시 프로그램을 만들어야하는 porting문제가 생김.

빨리 퇴근하려면 프로그램만드는건 다른 사람한테 맡기자.

client와 server가 데이터를 주고받을 때 규약이 필요해짐. protocol.

여러가지 protocol중 가장 인기있었던 것이 http.

http가 가장 많이 쓰이게 된 것은 개발자들이 편리했기 때문.

왜 가장 편리했을까?

개발이 쉬워서. 개발자들이 가장 좋아하는 데이터 포맷이 텍스트. 컴퓨터에서는 가장 비효율적인 것이 텍스트.

개발자들이 html로 텍스트 포맷으로 만들기만 하면 됨.

아무 웹서버에서나 다 적용가능.

client program의 web browser에서  http://ip.port/context/a.html 불러주면 응답하겠다.하는 것.

http://에서 //가 필요없지만 처음에 아무생각 없이 정해놓은 것이 에너지 자원 시간의 낭비를 불러온 것처럼 보안에서도 비슷한 일이 있었음.

비밀번호 정책에서 8자리 3가지 문자조합. 10자리 2가지 문자조합.

10자리 2가지 문자조합이 훨씬 안전하지만 대가가 8자리 3가지가 안전하다고해서 쏠림현상이 발생하게 됨.



## Web site 시대

정적 html+css+js

개발자들의 html선호가 http의 사용->브라우저 사용으로 이어지던 시대

회원가입, 로그인등을 지원하기 위해서는 웹서버 위에 올라가는 프로그램이어야함.(독립 프로그램이면 안됨)

하지만 이 시대 자체가 처음이다보니 개발자들이 다양한 언어(C,C++,Perl,VB등등 ) 시도해봄.

성공한 애들이 CGI(Common Gateway Interface). 웹 프로그램을 총칭하는 용어임.

저런 기술이 난무하던 시절에 개발자들이 미처 헤아리지 못했던 문제점이 있었음.

http는 프로토콜 특성으로 여러사람들의 요청을 동시에 받아들일 수 있게 디자인 되어있음.

다른 것들을 사용자들의 수가 정해져있었음.(connection을 유지해야함. 일부러 끊지 않는 이상)

하지만 http에서 request,response하고 나면 끊어져 버림. state connection less라고 함.

마치 이게 동시에 일어나는 것처럼 느껴지게 함.

이런 하나씩의 처리를 process라고 함.(ex : 회원가입 처리 3개, 프로세스 3개)

이런 process는 자원을 공유하지 않는 흐름이다.(ex: 이 강의장으로 비유를 들면 24명의 강사 24명의 학생, 24명의 강의실. 말도 안됨.)

지금 강의장은 thread 임. (자원을 공유함)

thread 프로그램이 짜는데 너무 오래걸리고 힘들어서 이걸 쉽게하기 위해서 

webserver vendor들이 나서기 시작함. netscape.(server와 client시장을 독점했었음)

netscape에서 NSAPI를 제공했음. 코딩이 되어있는 thread CGI를 제공.

microsoft에서는 ISAPI를 제공. 마찬가지로 thread기반의 CGI API.

이 시대 이후에 일시적으로 편해짐.

이 당시 있던 문제들

1. request가 process 단위로 돌아가는 문제. -> request가 thread 단위로 돌아가도록 바꿈.

2. Platform dependent 문제

   아무리 thread 기반으로 짜도 한 대의 컴퓨터가 감당할 수 있는 한계가 있음. 그래서 컴퓨터 머신을 2대 확보하고 2대를 1대처럼 활용해야함. 하지만, 이 2대가 똑같은 버전 똑같은 하드웨어로 될 가능성이 낮음. 그러면 NSAPI를 ISAPI로 가서 사용 가능한가? 불가능했음. 그래서 개발자들이 삽질하게 됨.  이걸 해결해주는 회사가 나타나지 않음.

   Sun 서버쪽 대형 머신 만드는 회사가 JAVA라고 하는 기술을 무료로 배포. 배포는 했지만 돈은 못 범. hp machine IBM machine 다른거나 씀. sun spac이 가장 잘 돌아가는데...

   hp IBM이 껌값으로 인수 제의 했었음. 거절

   그 때 DB만들던 Oracle이 제의. Sun의 MySQL을 죽이려는 목적. 원래는 EU 승인이 안났음.

   결국 2008년 Sun이 Oracle에 넘어감.

   Oracle의 목적은 JAVA 독식. MySQL 죽이기는 부차적인 목적.

   2014년에 모바일 웹브라우저 사용자가 PC 웹브라우저를 능가할 것을 2000년도에 예언. 그게 맞아떨어짐.

   빅데이터의 무서움.

   데이터를 가진 사람이 곧 권력을 갖게 됨. 그래서 구글은 악해지지 말자는 것이 모토.

   악의 평범성을 조심하자.

   구글은 2014년 모바일 시장이 PC시장보다 커지면 망할거라고 생각. 접근성이 떨어져서.

   해결책은 구글이 제조사들이 부족해하는 모바일 OS를 제공하고 거기에 구글을 깔도록 하는 것.

   캐나다 벤처회사 안드로이드를 발견. 발탁해서 현재는 구글 부사장.

   Sun에서 위의 문제점을 두가지 다 메꿔주는 Servlet을 개발해서 이것이 채택됨. 

   그래서 WORA(Write Once Read Anywhere)이 가능해짐.



아키텍처 얘기를 하기 위한 컴퓨팅 패러다임 얘기

아키텍처 얘기하기에는 김.

안드로이드의 language를 뭘로 할 것인가에 초점을 맞춤.

안드로이드는 C로 만들어져있음. 근데 구글이 JAVA를 선택함.(기존 web에서만 적용되던것을)

개발 편의성 때문에 선택함.

2008년부터 JAVA 개발자의 수가 C 개발자의 수를 넘어서기 시작. 이 개발자들을 빠르게 App시장으로 끌어들일 생각을 함.

JAVA는 JRE라는 JAVA 실행환경이 있음

JRE안에는 JAVA Virtual machine(JVM)이 또 있음.

JVM은 일반 환경에서 쓸때는 free software인데, mobile환경에서 쓸때는 sun에 라이센스 fee가 귀속되어있음.(돈내야됨)

jvm을 대체하기 위해 만든 것이 구글에서 만든 dvm(달빅 virtual machine) 달빅은 역삼처럼 개발자 고향.

오라클 법무팀에서 jvm의 코드 중 13가지 베낀 dvm에 법적 대응에 들어감.

안드로이드 진영에 오라클이 소송을 걸어서

처음 오라클이 이기고 두번째가 안드로이드 세번째 오라클이 이겼다.

곧 판결이 나는 상황. 돈주고 안드로이드 시장을 뺏겠다는 상황.

사고와 가치체계를 갖고 생각을 해야함. 단순히 기술만 배운다고 뭔가 바뀌지 않음.

추리소설을 쓰고 요리를 만들어라(논리력 극대화와 창의력)

파이썬은 집에서 해먹는 3분짜리 짜파게티 요리 수준.(백종원이 될 수는 없다.)

하지만, 백종원도 여기서부터 시작한 것처럼 작은 것부터 시작할 필요는 있다.



절차 중심에서는 북치고 장구치는 것을 차례대로 다 적었다면

객체지향에서는 북, 장구,  쳐라 하나씩을 다 정의해야함. 그래서 갔다왔다를 엄청 많이해야함.

객체지향은 컴퓨터 입장에서 보기에는 엄청나게 비효율적.

우리나라에서는 에반젤리스트급 프로그래머들이 JAVA를 배우고 곧 죽을 것이라고 했음.(그만큼 우리나라에서는 혜안을 가진 사람이 드뭄.)



2000년대 모바일 시대에 건국대학교 새천년강당에서 모바일 혜안을 얻기 원하는 개발자들이 전부 모여서 세션을 가짐.

작아질수록 더 가치 있게 생각하던 시대에서 "TV 보기 위해서는 커져야하지 않을까요?"하는 질문에 "누가 그렇게 큰걸 들고다니려고 하겠어"라고 교수가 얘기했었음. 그만큼 혜안이 중요함.



웹 서버를 구축할 때 







플랫폼 구축을 그림으로 표현하면

작업 디텍토리에 있는 html, css, javascript들 , Servelet(서버 어플리케이션이라는 뜻) Servelet에서는 요청이 온 것에 대해 1. 요청을 분석 2. biz(처리함) 3. 작업 결과를 응답함. (이런 응답 구조가 객체 지향 프로그래밍임. 각각 북치고 장구치고 꽹과리 치는 것. 절차중심적 프로그래밍은 copy&paste말고는 재사용할 방법이 없음.)

위의 biz(business componet)를 분리해서 이것을 model이라고 부름. 그래서 이것을 servelet에서 호출하여 사용할 수 있게 만듬.

javaEE(Enterprise edition) 안에 ee.jar라는 라이브러리가 있음. 하지만 내용은 별로 없음. 속빈 강정.

껍데기만 만든 것은 인터페이스임. 표준을 만든 것. 내가 정한대로 만들라는 얘기. ee.jar는 servlet을 보고 코딩은 하지만 돌아가지는 않음.  이것을 보고 구현한 구현체를 Web Container라고 부름. 이 web container는 servelet을 돌리는데 서비스 됨. 이 container은 다른 코드들을 support해주는 코드 집합임.  web container의 종류는 Tomcat,Resin, JRun, ...등이 있음. 뭘로 돌려도 똑같이 돌아갈 수 있게 설계되어 있음. Any Web Container

JavaSE(standard edition) 안에 JRE 안에 JVM이 있음.

JRE안에 rt.jar 라는 이름의 라이브러리가 있음. 

Any Web Server(Apache,NginX,IIS,NS) // http protocol listner임. 작업디텍토리에있는 html,css,javascript를 리턴해주는 역할. 하지만 이것만으로는 어떠한 처리도 못함.

Any O/S

Any H/W



java SE,EE말고도 ME(mobile edion이 있음)(법정 분쟁중)



텍스트는 바이너리 보다 부피가 400% cpu사용 용량 15% 증가 메모리 엄청나게 증가함.

servelet은 독립적이지 않아서 원하는 것만 딱 불러올 수 없음.

그래서 재사용하기 위해 biz를 분리하여 재사용할 수 있게 만듬.

직원의 UI와 biz 사이에서 통신을 하기 위해 rmi를 도입함.

rmi 는 java binary로 되어있어서 텍스트 통신에 비해서 어마어마하게 빠르고 해킹에 비해서도 안전함.

가장 보안상 위험한 것이 텍스트이지만, 그만큼 개발 편의성이 좋아서 개발자들이 가장 선호함.

기존에는 java 안에 html이 있었음. 그래서 요청 분석은 java 20%, 응답은 html 80%라면 개발자들이 응답을 80%를 매번 짜기 힘들기 때문에 디자이너에게 맡김.

근데 sun에서 이것을 뒤집어서 html 안에 java를 넣음. 이것이 jsp. 힘든 상황을 개선함. 그리고 servelet을 없애버림.



이 전체를 통틀어 model1 architecture라고 함.

하지만 이것에도 문제가 있었음. jsp가 수백,수천장 나온다는 것. 그리고 어떤페이지에서 어떤페이지로 넘어가는지 파악해야 유지보수가 쉬운데 이것이 어려워짐.

그래서 문제를 인식한 sun에서 다시 servelet을 다시 살려내고 servelet을 gate역할로 사용함.(요청 분석하는 역할 [ex 회원 가입 요청하면 {어떤biz를 보여주고,어떤 view를 보여줄게}],if로그인{biz,view})

여기서는 servelet은 controller역할로 gate역할을 하고 jsp는 view의 역할을 한다.

이렇게 바뀐 것을 model2 architecture라고 함. 이렇게 안 짜면 욕먹고 개 발자가 됨.



sun의 제임스 고슬링 팀원 중 한 사람이 servelet에 주목하면서 요청분석하는 것을 보면서 controlling하는 과정에서 if가 많이 들어간 것을 보고 xml으로 바꾸면 어떨까 하는 생각을 적용해봄.

회원가입 {biz,view} ->> <회원가입> <biz> <view>

이렇게 바꿔주는 것을 web struts라고 이름 붙임.

일일히 코딩할 필요 없고 선언만 해주면 되는 이것에 사람들이 호응하기 시작.

서비스 이용이 많아지자 이것을 아파치 재단에 기증함.

그래서 이것이 framework가 됨.

우리나라에서는 이 struts를 새로운 언어로 생각하고 배우러가는 사람도 생김(기술적 지식이 없어서 생긴 쏠림 현상)

코드가 5배 길어지고 instruction 5배 길어지고 performance 5배 나빠짐. 근데 개발자는 그냥 퇴근 빨리하기 위해서 채택하고 운영자는 싫어함.

나중에는 운영자들이 framework를 걷어내기 힘들어서 (갑을병정 최하위에게 하청 줘서 만들어주고 나가서 이걸 개선할 사람이 없음.) 하드웨어에 의존해서 서버증설하고 그렇게 되는거임.

biz는 multi request를 받으면 안정적으로 동작하는 것이 보장이 안됨.

안정성에 초점을 둬야함 (Tx[Transaction], Security, Persistence) 온 신경을 다 써야하는데 어렵고 스스로의 신뢰성을 검증하기 힘듬.

거기서 추가된 것이 enterprise java beans(EJB)이다. beans는 business component를 의미

EE는 항상 SE가 기반이 되어있어야함.

EE의 library 중 Tx에 대한 것을 구현한 security에 대한 것을 구현한 persistence에 대한 것을 구현한 엔진들을 application server라고 부름. 이 서버 종류에 Jeus, JBoss, WebLogic, Websphere,IPlanet, OracleApplicationServer(OAS)등이 있다

이 WAS들은 Web container 역할도 같이 함.

business component를 지원해주지 않으면 was가 아님. 그래서 tomcat이 was가 아닌 것.

xml에

<A><Tx>

<B><Security>

<C><Persistence>라고 써져있으면 이것을 요청할 때 servelet에서 was로 요청해야함.

어떤 프로토콜이 필요할까? rmi-iiop를 사용함. 전송 내용이 text가 아닌 binary 이므로 훨씬 해킹에 대해 안전함.

Controller(biz=Gate=Servelet)이 요청하고 JavaEE가 이것을 받아서 biz에서 내용을 받아오고 이것을 다시 거꾸로 돌려준다.

EJB 표준 스펙이 존재하고 확장해야하는 상황이었는데 개발자들이 이것을 이해하기 어려워해서 로드존슨이라는 사람이 나타나서 xml에 business componet를 묶어서 parser를 거쳐 biz에 전달하는 것을 개발함. 이것이 spring frame work이다.

개발자가 공개해서 open source community가 형성되어 Tx , Persistence, Security libary들을 추가해서 dependancy(의존)하라고 지정함. 근데 비표준인 것이 문제. 근데 너무 많은 사람들이 써서 사실상 표준 디팩토가 되버림.

우리나라에서는 EE 비표준을 표준으로 만들어서 전자정부 표준 framework를 만듬.

framework의 폐단은 performance가 엄청나게 비효율적임.

선생님이 직접 테스트했을 때는 생각했던 5배 비효율보다 훨씬 비효율적임.

따봤더니 코드 짠 내용들이 request가 오면 하나씩 올리기보다는 pool로 미리 확보해놓고 바로바로 대응이 되게 하는 것이 효율적인데 정부에서는 1개씩 5개를 각자 만들어서 1개씩 올리는 실수를 했음.

근데 담당자는 문책당하니까 다음 업데이트까지는 조용해달라고 했음 ㅠ 선생님 고민하다가 그냥 조용해줌. 근데 이게 IT업계의 세월호라고 생각. 이러지말장..

자신이 구조를 그리고 설명할 수 있는 수준까지 공부하자.

biz가 만약 다른 회사와 연동되어야한다면? (Java와 C처럼.)

java binary를 보내도 C에서 못알아들음.

그래서 User define protocol로 저쪽 개발자랑 이쪽 개발자가 만나서 규약을 정해야함.

이것을 SI(System Integration)이라고 한다. 매번 개발자들이 SI하면서 삽질할 수는 없으니 경험치가 쌓였다.

그래서 http를 전송 프로토콜로 정함.  http 를 통해서XML기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜을 새로 만듬

저쪽의 객체를 불러낼 수 있는 표준 SOAP(Simple Object Access Protocol)가 바로 그것.

여기까지가 Web Services이다.

1. Web site = 정적 html + CSS+js

2. Web Application = Web site + CGI
3. Web Services : B2B

이 3가지를 합쳐서 B2C.

요즘 기술은 SI쪽으로 가는 것이 아니라 개발 편의성이 가중되는 방향으로 가고 있음.

JAVA한 사람들이 Spring 하면서 가장 먼저 배우는 용어가 POJO(Plain Old Java Object). 평범하게 쓸 수 있게 해주는 것.

Spring을 쓰면 Application Server를 쓸 필요가 없지 않은가? 하는 질문을 생각해봐야함.

JVM이 메모리관리, 레지스터 역할, 프로그램 관리 다 해주는 실제 브레인 역할. 근데 동작하기 위해서는 JavaEE를 띄워야 작동할 수 있는 것. 그렇지만 spring dependancy까지 다 가져와서 쓰지도 않을 was를 쓰면서 모든 것을 jvm에 올려서 쓴다는 것은 비효율적인 구조인 것임.

개발자들을 제공하는 업체들은 영세해서 enterprise system을 구축하기 위해서 EJB 개발자로 훈련시켜서 보내기에는 3년이 더걸려서 그냥 사실상 표준이라고하는 spring만 빨리 가르쳐서 인력을 파는데에 초점을 맞추고 있음.

was없이 개발자를 공급하기에는 spring이 딱인 것.

또 개발자들은 enterprise 시스템 개발할 때 자기가 바꿨다가 문제가 생길 수 있기 때문에 선뜻 나서기 힘듬. 

거기에 was vendor가 들어와서 문제 사례를 제시하면서 24시간 대기해서 해결해주겠다고 하면 안 쓸수가 없게 됨.

이런 기형적인 구조에 반기를 드는 개발자들이 생기기 시작함.

was를 안쓸거면 spring을 최상단에 둘 수 있다. (servelet이랑 view, html 등등 있는 곳)

framework를 좋아하지는 않지만 만약 쓴다면 was와 같이 쓸모없는 것을 덜어낼 수 있어야한다.

이런 것을 architect가 잘 해낼 수 있어야 한다.

server application은 대부분의 CE기반 코볼기반으로 바뀐 상황.

사이즈가 너무 커서 1년~1년반정도 되는 기간에 엄청난 인력이 작업해야되서 소통에 문제가 생김. 소통을 잘 하는 것이 시스템을 안전하게 만드는 첫 걸음이 됨. 그래서 그림이 가장 쉬우니까 클래스 다이어그램 시퀀스 다이어그램 액티비티 다이어그램을 그려서 소통함.

언제 어떻게 다이어그램을 그릴지 정하는 것을 객체지향 방법론임.

이제 전체를 대비하고 준비하는 것은 비용과 시간 문제로 못함. 그래서 부분적으로 게릴라적으로 접근함. 3주 주면 하나 붙여넣고, 비즈니스 추가하고, 엔진추가하고 이런 식.

그래서 2011년 이후에는 애자일 방법론이 유행하게됨.(전체를 다 대비할 필요가 없게 됨.)

그래서 3주만에 프로젝트를 해내기 위해서는 functional language를 배우게 됨.대표적으로 파이썬.

client개발자들은 client들이 실제로 보는 화면을 위해 개발함.

이런 client개발자들이 엄청나게 많아짐.

java script를 서버단에 쓰기 위해서 구글에서 v8 engine을 만들어서 java se, java ee 없이 java script로 대체할 수 있게 됨.

이것을 node.js라고 함.

node.js는 개발자 편의성이 좋음. javascript는 오직 개발 편의성을 위해 쓰는것.node.js은 안정성이 있을까? 아니다.

java까지 알아야 좋다.

이슈가 돈이 된다.

블록체인은 DB 서비스라고 생각.

JavaSE와 JavaEE를 빼고 그 자리에 V8 엔진을 두고 위에 biz를 node로써 둔다.

사람들이 SOAP이 표준인데 안쓰고 REST를 쓴다.

네이버의 biz중하나인 지도API를 사용할 수 있다.

여러가지 API를 끌어다가 원하는 기능을 구현하는 것을 mesh up이라고 한다.

요청 포맷을 SOAP을 안쓰고 비표준인 REST을 쓰면 REST API라고 한다.

비표준은 예를들어 네이버 API에서 다음 API로 바꿀 때 모든 API 요청 코드를 전부 뜯어고쳐야 한다. 그것이 비표준의 폐해이다.

REST는 바꾸는 개발자는 불편하지만 기존 개발자가 편해서 요즘 그렇게 개발한다. 그게 대세.

파이썬도 돌아갈 때는 메모리에 객체로 올라감.

node.js도 메모리에 객체로 올라감. 하지만, 객체지향으로 안부르고 functional이라고 부름.

객체로 처리되기는 하지만 지향은 아닙니다.

java는 8부터 function도 지향하지만 객체도 지향한다고해서 정체성이 사라지고 있음.

architecture는 명확하고 깔끔해야 함.

리눅스를 배운 것은 서버시장으로의 진출을 대비.